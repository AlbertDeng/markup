<h1 class="title">The RFB Protocol</h1>
<p>This document is based on &quot;The RFB Protocol&quot; by Tristan Richardson of
RealVNC Ltd (formerly of Olivetti Research Ltd / AT&amp;T Labs Cambridge).</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction" id="id12">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#display-protocol" id="id13">2&nbsp;&nbsp;&nbsp;Display Protocol</a><ul class="auto-toc">
<li><a class="reference internal" href="#screen-model" id="id14">2.1&nbsp;&nbsp;&nbsp;Screen Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#input-protocol" id="id15">3&nbsp;&nbsp;&nbsp;Input Protocol</a></li>
<li><a class="reference internal" href="#representation-of-pixel-data" id="id16">4&nbsp;&nbsp;&nbsp;Representation of Pixel Data</a></li>
<li><a class="reference internal" href="#protocol-extensions" id="id17">5&nbsp;&nbsp;&nbsp;Protocol Extensions</a></li>
<li><a class="reference internal" href="#string-encodings" id="id18">6&nbsp;&nbsp;&nbsp;String Encodings</a></li>
<li><a class="reference internal" href="#protocol-messages" id="id19">7&nbsp;&nbsp;&nbsp;Protocol Messages</a><ul class="auto-toc">
<li><a class="reference internal" href="#handshaking-messages" id="id20">7.1&nbsp;&nbsp;&nbsp;Handshaking Messages</a><ul class="auto-toc">
<li><a class="reference internal" href="#protocolversion" id="id21">7.1.1&nbsp;&nbsp;&nbsp;ProtocolVersion</a></li>
<li><a class="reference internal" href="#security" id="id22">7.1.2&nbsp;&nbsp;&nbsp;Security</a></li>
<li><a class="reference internal" href="#securityresult" id="id23">7.1.3&nbsp;&nbsp;&nbsp;SecurityResult</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-types" id="id24">7.2&nbsp;&nbsp;&nbsp;Security Types</a><ul class="auto-toc">
<li><a class="reference internal" href="#none" id="id25">7.2.1&nbsp;&nbsp;&nbsp;None</a></li>
<li><a class="reference internal" href="#vnc-authentication" id="id26">7.2.2&nbsp;&nbsp;&nbsp;VNC Authentication</a></li>
<li><a class="reference internal" href="#tight-security-type" id="id27">7.2.3&nbsp;&nbsp;&nbsp;Tight Security Type</a></li>
<li><a class="reference internal" href="#vencrypt" id="id28">7.2.4&nbsp;&nbsp;&nbsp;VeNCrypt</a><ul class="auto-toc">
<li><a class="reference internal" href="#subtypes-with-tls-or-x509-prefix" id="id29">7.2.4.1&nbsp;&nbsp;&nbsp;Subtypes with TLS or X509 prefix</a></li>
<li><a class="reference internal" href="#subtypes-with-none-suffix" id="id30">7.2.4.2&nbsp;&nbsp;&nbsp;Subtypes with None suffix</a></li>
<li><a class="reference internal" href="#subtypes-with-vnc-suffix" id="id31">7.2.4.3&nbsp;&nbsp;&nbsp;Subtypes with Vnc suffix</a></li>
<li><a class="reference internal" href="#plain-subtype" id="id32">7.2.4.4&nbsp;&nbsp;&nbsp;Plain subtype</a></li>
<li><a class="reference internal" href="#subtypes-with-plain-suffix" id="id33">7.2.4.5&nbsp;&nbsp;&nbsp;Subtypes with Plain suffix</a></li>
<li><a class="reference internal" href="#subtypes-with-sasl-suffix" id="id34">7.2.4.6&nbsp;&nbsp;&nbsp;Subtypes with SASL suffix</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#initialisation-messages" id="id35">7.3&nbsp;&nbsp;&nbsp;Initialisation Messages</a><ul class="auto-toc">
<li><a class="reference internal" href="#clientinit" id="id36">7.3.1&nbsp;&nbsp;&nbsp;ClientInit</a></li>
<li><a class="reference internal" href="#serverinit" id="id37">7.3.2&nbsp;&nbsp;&nbsp;ServerInit</a></li>
</ul>
</li>
<li><a class="reference internal" href="#client-to-server-messages" id="id38">7.4&nbsp;&nbsp;&nbsp;Client to Server Messages</a><ul class="auto-toc">
<li><a class="reference internal" href="#setpixelformat" id="id39">7.4.1&nbsp;&nbsp;&nbsp;SetPixelFormat</a></li>
<li><a class="reference internal" href="#setencodings" id="id40">7.4.2&nbsp;&nbsp;&nbsp;SetEncodings</a></li>
<li><a class="reference internal" href="#framebufferupdaterequest" id="id41">7.4.3&nbsp;&nbsp;&nbsp;FramebufferUpdateRequest</a></li>
<li><a class="reference internal" href="#keyevent" id="id42">7.4.4&nbsp;&nbsp;&nbsp;KeyEvent</a></li>
<li><a class="reference internal" href="#pointerevent" id="id43">7.4.5&nbsp;&nbsp;&nbsp;PointerEvent</a></li>
<li><a class="reference internal" href="#clientcuttext" id="id44">7.4.6&nbsp;&nbsp;&nbsp;ClientCutText</a></li>
<li><a class="reference internal" href="#enablecontinuousupdates" id="id45">7.4.7&nbsp;&nbsp;&nbsp;EnableContinuousUpdates</a></li>
<li><a class="reference internal" href="#clientfence" id="id46">7.4.8&nbsp;&nbsp;&nbsp;ClientFence</a></li>
<li><a class="reference internal" href="#xvp-client-message" id="id47">7.4.9&nbsp;&nbsp;&nbsp;xvp Client Message</a></li>
<li><a class="reference internal" href="#setdesktopsize" id="id48">7.4.10&nbsp;&nbsp;&nbsp;SetDesktopSize</a></li>
<li><a class="reference internal" href="#gii-client-message" id="id49">7.4.11&nbsp;&nbsp;&nbsp;gii Client Message</a><ul class="auto-toc">
<li><a class="reference internal" href="#version" id="id50">7.4.11.1&nbsp;&nbsp;&nbsp;Version</a></li>
<li><a class="reference internal" href="#device-creation" id="id51">7.4.11.2&nbsp;&nbsp;&nbsp;Device Creation</a></li>
<li><a class="reference internal" href="#device-destruction" id="id52">7.4.11.3&nbsp;&nbsp;&nbsp;Device Destruction</a></li>
<li><a class="reference internal" href="#injecting-events" id="id53">7.4.11.4&nbsp;&nbsp;&nbsp;Injecting Events</a></li>
</ul>
</li>
<li><a class="reference internal" href="#qemu-client-message" id="id54">7.4.12&nbsp;&nbsp;&nbsp;QEMU Client Message</a><ul class="auto-toc">
<li><a class="reference internal" href="#qemu-extended-key-event-message" id="id55">7.4.12.1&nbsp;&nbsp;&nbsp;QEMU Extended Key Event Message</a></li>
<li><a class="reference internal" href="#qemu-audio-client-message" id="id56">7.4.12.2&nbsp;&nbsp;&nbsp;QEMU Audio Client Message</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#server-to-client-messages" id="id57">7.5&nbsp;&nbsp;&nbsp;Server to Client Messages</a><ul class="auto-toc">
<li><a class="reference internal" href="#framebufferupdate" id="id58">7.5.1&nbsp;&nbsp;&nbsp;FramebufferUpdate</a></li>
<li><a class="reference internal" href="#setcolourmapentries" id="id59">7.5.2&nbsp;&nbsp;&nbsp;SetColourMapEntries</a></li>
<li><a class="reference internal" href="#bell" id="id60">7.5.3&nbsp;&nbsp;&nbsp;Bell</a></li>
<li><a class="reference internal" href="#servercuttext" id="id61">7.5.4&nbsp;&nbsp;&nbsp;ServerCutText</a></li>
<li><a class="reference internal" href="#endofcontinuousupdates" id="id62">7.5.5&nbsp;&nbsp;&nbsp;EndOfContinuousUpdates</a></li>
<li><a class="reference internal" href="#serverfence" id="id63">7.5.6&nbsp;&nbsp;&nbsp;ServerFence</a></li>
<li><a class="reference internal" href="#xvp-server-message" id="id64">7.5.7&nbsp;&nbsp;&nbsp;xvp Server Message</a></li>
<li><a class="reference internal" href="#gii-server-message" id="id65">7.5.8&nbsp;&nbsp;&nbsp;gii Server Message</a><ul class="auto-toc">
<li><a class="reference internal" href="#id6" id="id66">7.5.8.1&nbsp;&nbsp;&nbsp;Version</a></li>
<li><a class="reference internal" href="#device-creation-response" id="id67">7.5.8.2&nbsp;&nbsp;&nbsp;Device Creation Response</a></li>
</ul>
</li>
<li><a class="reference internal" href="#qemu-server-message" id="id68">7.5.9&nbsp;&nbsp;&nbsp;QEMU Server Message</a><ul class="auto-toc">
<li><a class="reference internal" href="#qemu-audio-server-message" id="id69">7.5.9.1&nbsp;&nbsp;&nbsp;QEMU Audio Server Message</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#encodings" id="id70">7.6&nbsp;&nbsp;&nbsp;Encodings</a><ul class="auto-toc">
<li><a class="reference internal" href="#raw-encoding" id="id71">7.6.1&nbsp;&nbsp;&nbsp;Raw Encoding</a></li>
<li><a class="reference internal" href="#copyrect-encoding" id="id72">7.6.2&nbsp;&nbsp;&nbsp;CopyRect Encoding</a></li>
<li><a class="reference internal" href="#rre-encoding" id="id73">7.6.3&nbsp;&nbsp;&nbsp;RRE Encoding</a></li>
<li><a class="reference internal" href="#corre-encoding" id="id74">7.6.4&nbsp;&nbsp;&nbsp;CoRRE Encoding</a></li>
<li><a class="reference internal" href="#hextile-encoding" id="id75">7.6.5&nbsp;&nbsp;&nbsp;Hextile Encoding</a></li>
<li><a class="reference internal" href="#zlib-encoding" id="id76">7.6.6&nbsp;&nbsp;&nbsp;zlib Encoding</a></li>
<li><a class="reference internal" href="#tight-encoding" id="id77">7.6.7&nbsp;&nbsp;&nbsp;Tight Encoding</a></li>
<li><a class="reference internal" href="#zlibhex-encoding" id="id78">7.6.8&nbsp;&nbsp;&nbsp;zlibhex Encoding</a></li>
<li><a class="reference internal" href="#zrle-encoding" id="id79">7.6.9&nbsp;&nbsp;&nbsp;ZRLE Encoding</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pseudo-encodings" id="id80">7.7&nbsp;&nbsp;&nbsp;Pseudo-encodings</a><ul class="auto-toc">
<li><a class="reference internal" href="#jpeg-quality-level-pseudo-encoding" id="id81">7.7.1&nbsp;&nbsp;&nbsp;JPEG Quality Level Pseudo-encoding</a></li>
<li><a class="reference internal" href="#cursor-pseudo-encoding" id="id82">7.7.2&nbsp;&nbsp;&nbsp;Cursor Pseudo-encoding</a></li>
<li><a class="reference internal" href="#x-cursor-pseudo-encoding" id="id83">7.7.3&nbsp;&nbsp;&nbsp;X Cursor Pseudo-encoding</a></li>
<li><a class="reference internal" href="#desktopsize-pseudo-encoding" id="id84">7.7.4&nbsp;&nbsp;&nbsp;DesktopSize Pseudo-encoding</a><ul class="auto-toc">
<li><a class="reference internal" href="#server-semantics" id="id85">7.7.4.1&nbsp;&nbsp;&nbsp;Server Semantics</a></li>
<li><a class="reference internal" href="#client-semantics" id="id86">7.7.4.2&nbsp;&nbsp;&nbsp;Client Semantics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lastrect-pseudo-encoding" id="id87">7.7.5&nbsp;&nbsp;&nbsp;LastRect Pseudo-encoding</a></li>
<li><a class="reference internal" href="#compression-level-pseudo-encoding" id="id88">7.7.6&nbsp;&nbsp;&nbsp;Compression Level Pseudo-encoding</a></li>
<li><a class="reference internal" href="#qemu-pointer-motion-change-psuedo-encoding" id="id89">7.7.7&nbsp;&nbsp;&nbsp;QEMU Pointer Motion Change Psuedo-encoding</a></li>
<li><a class="reference internal" href="#qemu-extended-key-event-psuedo-encoding" id="id90">7.7.8&nbsp;&nbsp;&nbsp;QEMU Extended Key Event Psuedo-encoding</a></li>
<li><a class="reference internal" href="#qemu-audio-psuedo-encoding" id="id91">7.7.9&nbsp;&nbsp;&nbsp;QEMU Audio Psuedo-encoding</a></li>
<li><a class="reference internal" href="#gii-pseudo-encoding" id="id92">7.7.10&nbsp;&nbsp;&nbsp;gii Pseudo-encoding</a></li>
<li><a class="reference internal" href="#desktopname-pseudo-encoding" id="id93">7.7.11&nbsp;&nbsp;&nbsp;DesktopName Pseudo-encoding</a></li>
<li><a class="reference internal" href="#extendeddesktopsize-pseudo-encoding" id="id94">7.7.12&nbsp;&nbsp;&nbsp;ExtendedDesktopSize Pseudo-encoding</a></li>
<li><a class="reference internal" href="#xvp-pseudo-encoding" id="id95">7.7.13&nbsp;&nbsp;&nbsp;xvp Pseudo-encoding</a></li>
<li><a class="reference internal" href="#fence-pseudo-encoding" id="id96">7.7.14&nbsp;&nbsp;&nbsp;Fence Pseudo-encoding</a></li>
<li><a class="reference internal" href="#continuousupdates-pseudo-encoding" id="id97">7.7.15&nbsp;&nbsp;&nbsp;ContinuousUpdates Pseudo-encoding</a></li>
<li><a class="reference internal" href="#jpeg-fine-grained-quality-level-pseudo-encoding" id="id98">7.7.16&nbsp;&nbsp;&nbsp;JPEG Fine-Grained Quality Level Pseudo-encoding</a></li>
<li><a class="reference internal" href="#jpeg-subsampling-level-pseudo-encoding" id="id99">7.7.17&nbsp;&nbsp;&nbsp;JPEG Subsampling Level Pseudo-Encoding</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2><a class="toc-backref" href="#id12">1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>RFB (&quot;remote framebuffer&quot;) is a simple protocol for remote access to
graphical user interfaces. Because it works at the framebuffer level it
is applicable to all windowing systems and applications, including X11,
Windows and Macintosh. RFB is the protocol used in VNC (Virtual Network
Computing).</p>
<p>The remote endpoint where the user sits (i.e. the display plus keyboard
and/or pointer) is called the RFB client or viewer. The endpoint where
changes to the framebuffer originate (i.e. the windowing system and
applications) is known as the RFB server.</p>
<p>RFB is truly a &quot;thin client&quot; protocol. The emphasis in the design of
the RFB protocol is to make very few requirements of the client. In
this way, clients can run on the widest range of hardware, and the task
of implementing a client is made as simple as possible.</p>
<p>The protocol also makes the client stateless. If a client disconnects
from a given server and subsequently reconnects to that same server,
the state of the user interface is preserved. Furthermore, a different
client endpoint can be used to connect to the same RFB server. At the
new endpoint, the user will see exactly the same graphical user
interface as at the original endpoint. In effect, the interface to the
user's applications becomes completely mobile. Wherever suitable
network connectivity exists, the user can access their own personal
applications, and the state of these applications is preserved between
accesses from different locations. This provides the user with a
familiar, uniform view of the computing infrastructure wherever they
go.</p>
<h2><a class="toc-backref" href="#id13">2&nbsp;&nbsp;&nbsp;Display Protocol</a></h2>
<p>The display side of the protocol is based around a single graphics
primitive: &quot;put a rectangle of pixel data at a given x,y position&quot;. At
first glance this might seem an inefficient way of drawing many user
interface components. However, allowing various different encodings for
the pixel data gives us a large degree of flexibility in how to trade
off various parameters such as network bandwidth, client drawing speed
and server processing speed.</p>
<p>A sequence of these rectangles makes a <em>framebuffer update</em> (or simply
<em>update</em>). An update represents a change from one valid framebuffer
state to another, so in some ways is similar to a frame of video. The
rectangles in an update are usually disjoint but this is not
necessarily the case.</p>
<p>The update protocol is demand-driven by the client. That is, an update
is only sent from the server to the client in response to an explicit
request from the client. This gives the protocol an adaptive quality.
The slower the client and the network are, the lower the rate of
updates becomes. With typical applications, changes to the same area of
the framebuffer tend to happen soon after one another. With a slow
client and/or network, transient states of the framebuffer can be
ignored, resulting in less network traffic and less drawing for the
client.</p>
<h3><a class="toc-backref" href="#id14">2.1&nbsp;&nbsp;&nbsp;Screen Model</a></h3>
<p>In its simplest form, the RFB protocol uses a single, rectangular
framebuffer. All updates are contained within this buffer and may not
extend outside of it. A client with basic functionality simply presents
this buffer to the user, padding or cropping it as necessary to fit
the user's display.</p>
<p>More advanced RFB clients and servers have the ability to extend this
model and add multiple screens. The purpose being to create a
server-side representation of the client's physical layout.
Applications can use this information to properly position themselves
with regard to screen borders.</p>
<p>In the multiple-screen model, there is still just a single framebuffer
and framebuffer updates are unaffected by the screen layout. This
assures compatibility between basic clients and advanced servers.
Screens are added to this model and act like viewports into the
framebuffer. A basic client acts as if there is a single screen
covering the entire framebuffer.</p>
<p>The server may support up to 255 screens, which must be contained fully
within the current framebuffer. Multiple screens may overlap partially
or completely.</p>
<p>The client must keep track of the contents of the entire framebuffer,
not just the areas currently covered by a screen. Similarly, the server
is free to use encodings that rely on contents currently not visible
inside any screen. For example it may issue a <em>CopyRect</em> rectangle from
any part of the framebuffer that should already be known to the client.</p>
<p>The client can request changes to the framebuffer size and screen
layout. The server is free to approve or deny these requests at will,
but must always inform the client of the result. See the
<a class="reference internal" href="#setdesktopsize">SetDesktopSize</a> message for details.</p>
<p>If the framebuffer size changes, for whatever reason, then all data in
it is invalidated and considered undefined. The server must not use
any encoding that relies on the previous framebuffer contents. Note
however that the semantics for <em>DesktopSize</em> are not well-defined and
do not follow this behaviour in all server implementations. See the
<a class="reference internal" href="#desktopsize-pseudo-encoding">DesktopSize Pseudo-encoding</a> chapter for full details.</p>
<p>Changing only the screen layout does not affect the framebuffer
contents. The client must therefore keep track of the current
framebuffer dimensions and compare it with the one received in the
<em>ExtendedDesktopSize</em> rectangle. Only when they differ may it discard
the framebuffer contents.</p>
<h2><a class="toc-backref" href="#id15">3&nbsp;&nbsp;&nbsp;Input Protocol</a></h2>
<p>The input side of the protocol is based on a standard workstation model
of a keyboard and multi-button pointing device. Input events are simply
sent to the server by the client whenever the user presses a key or
pointer button, or whenever the pointing device is moved. These input
events can also be synthesised from other non-standard I/O devices. For
example, a pen-based handwriting recognition engine might generate
keyboard events.</p>
<p>If you have an input source that does not fit this standard workstation
model, the General Input Interface (gii) protocol extension provides
possibilities for input sources with more axes, relative movement and
more buttons.</p>
<h2><a class="toc-backref" href="#id16">4&nbsp;&nbsp;&nbsp;Representation of Pixel Data</a></h2>
<p>Initial interaction between the RFB client and server involves a
negotiation of the <em>format</em> and <em>encoding</em> with which pixel data will
be sent. This negotiation has been designed to make the job of the
client as easy as possible. The bottom line is that the server must
always be able to supply pixel data in the form the client wants.
However if the client is able to cope equally with several different
formats or encodings, it may choose one which is easier for the server
to produce.</p>
<p>Pixel <em>format</em> refers to the representation of individual colours by
pixel values. The most common pixel formats are 24-bit or 16-bit &quot;true
colour&quot;, where bit-fields within the pixel value translate directly to
red, green and blue intensities, and 8-bit &quot;colour map&quot; where an
arbitrary mapping can be used to translate from pixel values to the RGB
intensities.</p>
<p><em>Encoding</em> refers to how a rectangle of pixel data will be sent on the
wire. Every rectangle of pixel data is prefixed by a header giving the
X,Y position of the rectangle on the screen, the width and height of
the rectangle, and an <em>encoding type</em> which specifies the encoding of
the pixel data. The data itself then follows using the specified
encoding.</p>
<h2><a class="toc-backref" href="#id17">5&nbsp;&nbsp;&nbsp;Protocol Extensions</a></h2>
<p>There are a number of ways in which the protocol can be extended:</p>
<dl class="docutils">
<dt>New encodings</dt>
<dd>A new encoding type can be added to the protocol relatively easily
whilst maintaining compatibility with existing clients and servers.
Existing servers will simply ignore requests for a new encoding
which they don't support. Existing clients will never request the
new encoding so will never see rectangles encoded that way.</dd>
<dt>Pseudo encodings</dt>
<dd>In addition to genuine encodings, a client can request a &quot;pseudo-
encoding&quot; to declare to the server that it supports a certain
extension to the protocol. A server which does not support the
extension will simply ignore the pseudo-encoding. Note that this
means the client must assume that the server does not support the
extension until it gets some extension-specific confirmation from
the server. See <a class="reference internal" href="#pseudo-encodings">Pseudo-encodings</a> for a description of current
pseudo-encodings.</dd>
<dt>New security types</dt>
<dd>Adding a new security type gives the ultimate flexibility in
modifying the behaviour of the protocol without sacrificing
compatibility with existing clients and servers. A client and
server which agree on a new security type can effectively talk
whatever protocol they like after that, it doesn't necessarily have
to be anything like the RFB protocol.</dd>
</dl>
<p><strong>Under no circumstances should you use a different protocol version
number</strong>. If you use a different protocol version number then you are
not RFB / VNC compatible.</p>
<p>All three mechanisms for extensions are handled by RealVNC Ltd. To
ensure that you stay compatible with the RFB protocol it is important
that you contact RealVNC Ltd to make sure that your encoding types and
security types do not clash. Please see the RealVNC website at
<a class="reference external" href="http://www.realvnc.com">http://www.realvnc.com</a> for details of how to contact them.</p>
<h2><a class="toc-backref" href="#id18">6&nbsp;&nbsp;&nbsp;String Encodings</a></h2>
<p>The encoding used for strings in the protocol has historically often
been unspecified, or has changed between versions of the protocol. As a
result, there are a lot of implementations which use different,
incompatible encodings. Commonly those encodings have been ISO 8859-1
(also known as Latin-1) or Windows code pages.</p>
<p>It is strongly recommended that new implementations use the UTF-8
encoding for these strings. This allows full unicode support, yet
retains good compatibility with older RFB implementations.</p>
<p>New protocol additions that do not have a legacy problem should mandate
the UTF-8 encoding to provide full character support and to avoid any
issues with ambiguity.</p>
<p>All clients and servers should be prepared to receive invalid UTF-8
sequences at all times. These can occur as a result of historical
ambiguity or because of bugs. Neither case should result in lost
protocol synchronization.</p>
<p>Handling an invalid UTF-8 sequence is largely dependent on the role
that string plays. Modifying the string should only be done when the
string is only used in the user interface. It should be obvious in that
case that the string has been modified, e.g. by appending a notice to
the string.</p>
<h2><a class="toc-backref" href="#id19">7&nbsp;&nbsp;&nbsp;Protocol Messages</a></h2>
<p>The RFB protocol can operate over any reliable transport, either byte-
stream or message-based. Conventionally it is used over a TCP/IP
connection. There are three stages to the protocol. First is the
handshaking phase, the purpose of which is to agree upon the protocol
version and the type of security to be used. The second stage is an
initialisation phase where the client and server exchange <em>ClientInit</em>
and <em>ServerInit</em> messages. The final stage is the normal protocol
interaction. The client can send whichever messages it wants, and may
receive messages from the server as a result. All these messages begin
with a <em>message-type</em> byte, followed by any message-specific data.</p>
<p>The following descriptions of protocol messages use the basic types
<tt class="docutils literal">U8</tt>, <tt class="docutils literal">U16</tt>, <tt class="docutils literal">U32</tt>, <tt class="docutils literal">S8</tt>, <tt class="docutils literal">S16</tt>, <tt class="docutils literal">S32</tt>. These represent
respectively 8, 16 and 32-bit unsigned integers and 8, 16 and 32-bit
signed integers. All multiple byte integers (other than pixel values
themselves) are in big endian order (most significant byte first).</p>
<p>However, some protocol extensions use protocol messages that have types
that may be in little endian order. These endian agnostic types are
<tt class="docutils literal">EU16</tt>, <tt class="docutils literal">EU32</tt>, <tt class="docutils literal">ES16</tt>, <tt class="docutils literal">ES32</tt>, with some extension specific
indicator of the endianess.</p>
<p>The type <tt class="docutils literal">PIXEL</tt> is taken to mean a pixel value of <em>bytesPerPixel</em>
bytes, where 8 * <em>bytesPerPixel</em> is the number of <em>bits-per-pixel</em> as
agreed by the client and server, either in the <em>ServerInit</em> message
(<a class="reference internal" href="#serverinit">ServerInit</a>) or a <em>SetPixelFormat</em> message (<a class="reference internal" href="#setpixelformat">SetPixelFormat</a>).</p>
<h3><a class="toc-backref" href="#id20">7.1&nbsp;&nbsp;&nbsp;Handshaking Messages</a></h3>
<h4><a class="toc-backref" href="#id21">7.1.1&nbsp;&nbsp;&nbsp;ProtocolVersion</a></h4>
<p>Handshaking begins by the server sending the client a <em>ProtocolVersion</em>
message. This lets the client know which is the highest RFB protocol
version number supported by the server. The client then replies with a
similar message giving the version number of the protocol which should
actually be used (which may be different to that quoted by the server).
A client should never request a protocol version higher than that
offered by the server. It is intended that both clients and servers may
provide some level of backwards compatibility by this mechanism.</p>
<p>The only published protocol versions at this time are 3.3, 3.7, 3.8
(version 3.5 was wrongly reported by some clients, but this should be
interpreted by all servers as 3.3). Addition of a new encoding or
pseudo-encoding type does not require a change in protocol version,
since a server can simply ignore encodings it does not understand.</p>
<p>The <em>ProtocolVersion</em> message consists of 12 bytes interpreted as a
string of ASCII characters in the format &quot;<tt class="docutils literal">RFB xxx.yyy\n</tt>&quot; where
<tt class="docutils literal">xxx</tt> and <tt class="docutils literal">yyy</tt> are the major and minor version numbers, padded
with zeros.</p>
<table class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>12</td>
<td>&quot;<tt class="docutils literal">RFB 003.003\n</tt>&quot;
(hex 52 46 42 20 30 30 33 2e 30 30 33 0a)</td>
</tr>
</tbody>
</table>
<p>or</p>
<table class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>12</td>
<td>&quot;<tt class="docutils literal">RFB 003.007\n</tt>&quot;
(hex 52 46 42 20 30 30 33 2e 30 30 37 0a)</td>
</tr>
</tbody>
</table>
<p>or</p>
<table class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>12</td>
<td>&quot;<tt class="docutils literal">RFB 003.008\n</tt>&quot;
(hex 52 46 42 20 30 30 33 2e 30 30 38 0a)</td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id22">7.1.2&nbsp;&nbsp;&nbsp;Security</a></h4>
<p>Once the protocol version has been decided, the server and client must
agree on the type of security to be used on the connection.</p>
<dl class="docutils">
<dt>Version 3.7 onwards</dt>
<dd><p class="first">The server lists the security types which it supports:</p>
<table class="docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>number-of-security-types</em></td>
</tr>
<tr><td><em>number-of-security-types</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>security-types</em></td>
</tr>
</tbody>
</table>
<p>If the server listed at least one valid security type supported by
the client, the client sends back a single byte indicating which
security type is to be used on the connection:</p>
<table class="docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>security-type</em></td>
</tr>
</tbody>
</table>
<p>If <em>number-of-security-types</em> is zero, then for some reason the
connection failed (e.g. the server cannot support the desired
protocol version). This is followed by a string describing the
reason (where a string is specified as a length followed by that
many ASCII characters):</p>
<table class="docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>reason-length</em></td>
</tr>
<tr><td><em>reason-length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>reason-string</em></td>
</tr>
</tbody>
</table>
<p class="last">The server closes the connection after sending the <em>reason-string</em>.</p>
</dd>
<dt>Version 3.3</dt>
<dd><p class="first">The server decides the security type and sends a single word:</p>
<table class="docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>security-type</em></td>
</tr>
</tbody>
</table>
<p class="last">The <em>security-type</em> may only take the value 0, 1 or 2. A value of 0
means that the connection has failed and is followed by a string
giving the reason, as described above.</p>
</dd>
</dl>
<p>The security types defined in this document are:</p>
<table class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Number</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>Invalid</td>
</tr>
<tr><td>1</td>
<td><a class="reference internal" href="#none">None</a></td>
</tr>
<tr><td>2</td>
<td><a class="reference internal" href="#vnc-authentication">VNC Authentication</a></td>
</tr>
<tr><td>16</td>
<td><a class="reference internal" href="#tight-security-type">Tight Security Type</a></td>
</tr>
<tr><td>19</td>
<td><a class="reference internal" href="#vencrypt">VeNCrypt</a></td>
</tr>
</tbody>
</table>
<p>Other registered security types are:</p>
<table class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Number</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>3-4</td>
<td>RealVNC</td>
</tr>
<tr><td>5</td>
<td>RA2</td>
</tr>
<tr><td>6</td>
<td>RA2ne</td>
</tr>
<tr><td>7-15</td>
<td>RealVNC</td>
</tr>
<tr><td>17</td>
<td>Ultra</td>
</tr>
<tr><td>18</td>
<td>TLS</td>
</tr>
<tr><td>20</td>
<td>SASL</td>
</tr>
<tr><td>21</td>
<td>MD5 hash authentication</td>
</tr>
<tr><td>22</td>
<td>xvp</td>
</tr>
<tr><td>30-35</td>
<td>Apple Inc.</td>
</tr>
<tr><td>128-255</td>
<td>RealVNC</td>
</tr>
</tbody>
</table>
<p>The official, up-to-date list is maintained by IANA <a class="footnote-reference" href="#reg" id="id1">[1]</a>.</p>
<table class="docutils footnote" frame="void" id="reg" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id5">3</a>, <a class="fn-backref" href="#id7">4</a>)</em> <a class="reference external" href="http://www.iana.org/assignments/rfb/rfb.xml">http://www.iana.org/assignments/rfb/rfb.xml</a></td></tr>
</tbody>
</table>
<p>Once the <em>security-type</em> has been decided, data specific to that
<em>security-type</em> follows (see <a class="reference internal" href="#security-types">Security Types</a> for details). At the end
of the security handshaking phase, the protocol normally continues with
the <em>SecurityResult</em> message.</p>
<p>Note that after the security handshaking phase, it is possible that
further protocol data is over an encrypted or otherwise altered
channel.</p>
<h4><a class="toc-backref" href="#id23">7.1.3&nbsp;&nbsp;&nbsp;SecurityResult</a></h4>
<p>The server sends a word to inform the client whether the security
handshaking was successful.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="16%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td>status:</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>0</td>
<td>OK</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>1</td>
<td>failed</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>2</td>
<td>failed, too many attempts <a class="footnote-reference" href="#id3" id="id2">[2]</a></td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Only valid if the <a class="reference internal" href="#tight-security-type">Tight Security Type</a> is enabled.</td></tr>
</tbody>
</table>
<p>If successful, the protocol passes to the initialisation phase
(<a class="reference internal" href="#initialisation-messages">Initialisation Messages</a>).</p>
<dl class="docutils">
<dt>Version 3.8 onwards</dt>
<dd><p class="first">If unsuccessful, the server sends a string describing the reason
for the failure, and then closes the connection:</p>
<table class="last docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>reason-length</em></td>
</tr>
<tr><td><em>reason-length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>reason-string</em></td>
</tr>
</tbody>
</table>
</dd>
<dt>Version 3.3 and 3.7</dt>
<dd>If unsuccessful, the server closes the connection.</dd>
</dl>
<h3><a class="toc-backref" href="#id24">7.2&nbsp;&nbsp;&nbsp;Security Types</a></h3>
<h4><a class="toc-backref" href="#id25">7.2.1&nbsp;&nbsp;&nbsp;None</a></h4>
<p>No authentication is needed and protocol data is to be sent
unencrypted.</p>
<dl class="docutils">
<dt>Version 3.8 onwards</dt>
<dd>The protocol continues with the <em>SecurityResult</em> message.</dd>
<dt>Version 3.3 and 3.7</dt>
<dd>The protocol passes to the initialisation phase
(<a class="reference internal" href="#initialisation-messages">Initialisation Messages</a>).</dd>
</dl>
<h4><a class="toc-backref" href="#id26">7.2.2&nbsp;&nbsp;&nbsp;VNC Authentication</a></h4>
<p>VNC authentication is to be used and protocol data is to be sent
unencrypted. The server sends a random 16-byte challenge:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>16</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>challenge</em></td>
</tr>
</tbody>
</table>
<p>The client encrypts the challenge with DES, using a password supplied
by the user as the key, and sends the resulting 16-byte response:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>16</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>response</em></td>
</tr>
</tbody>
</table>
<p>The protocol continues with the <em>SecurityResult</em> message.</p>
<h4><a class="toc-backref" href="#id27">7.2.3&nbsp;&nbsp;&nbsp;Tight Security Type</a></h4>
<p>The Tight security type is a generic protocol extension that allows for
three things:</p>
<dl class="docutils">
<dt>Tunneling of data</dt>
<dd>A tunnel can be e.g. encryption, or indeed a no-op tunnel.</dd>
<dt>Authentication</dt>
<dd>The Tight security type allows for flexible authentication of the
client, which is typically one of the other security types.</dd>
<dt>Server capabilities</dt>
<dd>As a last step the Tight security type extends the <a class="reference internal" href="#serverinit">ServerInit</a>
message and enables the server to let the client know about the
server capabilities in terms of encodings and supported message
types.</dd>
</dl>
<p>The Tight security type is under the control of the TightVNC project,
and any new numbers must be registered with that project before they
can be added to any of the lists of Tight capabilities. It is strongly
recommended that any messages and security types registered with
RealVNC are also registered with the TightVNC project (register
security types as Tight authentication capabilities) in order to
eliminate clashes as much as is possible. Same thing with new
encodings, but in that case the problem is not as severe as the
TightVNC project are not using any encodings that are not registered
with RealVNC. Please see the TightVNC website at
<a class="reference external" href="http://www.tightvnc.com/">http://www.tightvnc.com/</a> for details on how to contact the project.</p>
<p>After the Tight security type has been selected, the server starts by
sending a list of supported tunnels, in order of preference:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>number-of-tunnels</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-tunnels</em> repetitions of the following:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>16</td>
<td><tt class="docutils literal">CAPABILITY</tt></td>
<td><em>tunnel</em></td>
</tr>
</tbody>
</table>
<p>where <tt class="docutils literal">CAPABILITY</tt> is</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">S32</tt></td>
<td><em>code</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>vendor</em></td>
</tr>
<tr><td>8</td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>signature</em></td>
</tr>
</tbody>
</table>
<p>Note that the <em>code</em> is not the only thing identifying a capability.
The client must ensure that all members of the structure match before
using the capability. Also note that <em>code</em> is <tt class="docutils literal">U32</tt> in the original
Tight documentation and implementation, but since <em>code</em> is used to
hold encoding numbers we have selected <tt class="docutils literal">S32</tt> in this document.</p>
<p>The following tunnel capabilities are registered:</p>
<table class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="22%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Code</th>
<th class="head">Vendor</th>
<th class="head">Signature</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">NOTUNNEL</tt>&quot;</td>
<td>No tunneling</td>
</tr>
</tbody>
</table>
<p>If <em>number-of-tunnels</em> is non-zero, the client has to request a tunnel
from the list with a tunneling method request:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">S32</tt></td>
<td><em>code</em></td>
</tr>
</tbody>
</table>
<p>If <em>number-of-tunnels</em> is zero, the client must make no such request,
instead the server carries on with sending the list of supported
authentication types, in order of preference:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>number-of-auth-types</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-auth-types</em> repetitions of the following:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>16</td>
<td><tt class="docutils literal">CAPABILITY</tt></td>
<td><em>auth-type</em></td>
</tr>
</tbody>
</table>
<p>The following authentication capabilities are registered:</p>
<table class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="22%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Code</th>
<th class="head">Vendor</th>
<th class="head">Signature</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td>&quot;<tt class="docutils literal">STDV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">NOAUTH__</tt>&quot;</td>
<td><a class="reference internal" href="#none">None</a></td>
</tr>
<tr><td>2</td>
<td>&quot;<tt class="docutils literal">STDV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">VNCAUTH_</tt>&quot;</td>
<td><a class="reference internal" href="#vnc-authentication">VNC Authentication</a></td>
</tr>
<tr><td>19</td>
<td>&quot;<tt class="docutils literal">VENC</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">VENCRYPT</tt>&quot;</td>
<td>VeNCrypt Security</td>
</tr>
<tr><td>20</td>
<td>&quot;<tt class="docutils literal">GTKV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">SASL____</tt>&quot;</td>
<td>Simple Authentication and Security
Layer (SASL)</td>
</tr>
<tr><td>129</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">ULGNAUTH</tt>&quot;</td>
<td>Unix Login Authentication</td>
</tr>
<tr><td>130</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">XTRNAUTH</tt>&quot;</td>
<td>External Authentication</td>
</tr>
</tbody>
</table>
<p>If <em>number-of-auth-types</em> is non-zero, the client has to request an
authentication type from the list with an authentication scheme
request:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">S32</tt></td>
<td><em>code</em></td>
</tr>
</tbody>
</table>
<p>For <em>code</em> 1, the protocol the proceeds at security type <a class="reference internal" href="#none">None</a> and
for <em>code</em> 2 it proceeds at security type <a class="reference internal" href="#vnc-authentication">VNC Authentication</a>.</p>
<p>If <em>number-of-auth-types</em> is zero, the protocol the proceeds directly
at security type <a class="reference internal" href="#none">None</a>.</p>
<p>Note that the <a class="reference internal" href="#serverinit">ServerInit</a> message is extended when the Tight security
type has been activated.</p>
<h4><a class="toc-backref" href="#id28">7.2.4&nbsp;&nbsp;&nbsp;VeNCrypt</a></h4>
<p>The VeNCrypt security type is a generic authentication method which
encapsulates multiple authentication subtypes.</p>
<p>After VeNCrypt security type is selected server sends the highest
version of VeNCrypt it can support. Although two versions exist, 0.1
and 0.2, this document describes only newer version 0.2.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="10%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>0</td>
<td>Major version number</td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>2</td>
<td>Minor version number</td>
</tr>
</tbody>
</table>
<p>Then client sends back the highest VeNCrypt version it can support, up to
version that it received from the server.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>Major version number</td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>Minor version number</td>
</tr>
</tbody>
</table>
<p>After that server sends one byte response which indicates if everything
is OK. Non-zero value means failure and connection will be closed. Zero
value means success.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>Ack</td>
</tr>
</tbody>
</table>
<p>Then server sends list of supported VeNCrypt subtypes.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="22%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>subtypes length</td>
</tr>
<tr><td>subtypes length</td>
<td><tt class="docutils literal">U32</tt> array</td>
<td>subtypes</td>
</tr>
</tbody>
</table>
<p>Following VeNCrypt subtypes are defined in this document:</p>
<table class="docutils">
<colgroup>
<col width="21%" />
<col width="21%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Code</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>256</td>
<td>Plain</td>
<td>Plain authentication (should be never used)</td>
</tr>
<tr><td>257</td>
<td>TLSNone</td>
<td>TLS encryption with no authentication</td>
</tr>
<tr><td>258</td>
<td>TLSVnc</td>
<td>TLS encryption with VNC authentication</td>
</tr>
<tr><td>259</td>
<td>TLSPlain</td>
<td>TLS encryption with Plain authentication</td>
</tr>
<tr><td>260</td>
<td>X509None</td>
<td>X509 encryption with plain password</td>
</tr>
<tr><td>261</td>
<td>X509Vnc</td>
<td>X509 encryption with VNC authentication</td>
</tr>
<tr><td>262</td>
<td>X509Plain</td>
<td>X509 encryption with Plain authentication</td>
</tr>
<tr><td>263</td>
<td>TLSSASL</td>
<td>TLS encryption with SASL authentication</td>
</tr>
<tr><td>264</td>
<td>X509SASL</td>
<td>X509 encryption with SASL authentication</td>
</tr>
</tbody>
</table>
<p>After that client selects one VeNCrypt subtype sends back number of that
type.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U32</tt></td>
<td>Selected VeNCrypt subtype</td>
</tr>
</tbody>
</table>
<p>If client supports none of the VeNCrypt subtypes it terminates
connection.</p>
<p>When subtype is selected authentication continues as written in particular
VeNCrypt subtype description.</p>
<h5><a class="toc-backref" href="#id29">7.2.4.1&nbsp;&nbsp;&nbsp;Subtypes with TLS or X509 prefix</a></h5>
<p>All those subtypes use TLS-encrypted stream and server use anonymous X509
certificate (subtypes with the TLS prefix) or valid X509 certificate
(subtypes with the X509 prefix). When session is negotiated, all further
traffic is send via this encrypted channel.</p>
<p>After receiving the U32 confirmation of the VeNCrypt subtype,
the TLS handshake is performed between the client and server.
If the handshake is unsuccessful the connection must be closed
and no further RFB protocol messages attempted.</p>
<p>Note about TLS parameters, like algorithm and key length. VeNCrypt
doesn't enforce any restriction, setting should be determined by local
security policy on client, respective server, side. This also applies
for validity of the server certificate, client side can decide if it
wants to accept invalid server certificate.</p>
<p>In case TLS handshake is not successful, detailed information of failure
can be obtained from underlying TLS stream and both sides must close the
connection.</p>
<p>In case TLS handshake is successful and TLS channel is estabilished,
VeNCrypt authentication can continue.</p>
<h5><a class="toc-backref" href="#id30">7.2.4.2&nbsp;&nbsp;&nbsp;Subtypes with None suffix</a></h5>
<p>After TLS handshake, authentication is successful and both sides
can continue with the <a class="reference internal" href="#securityresult">SecurityResult</a> message.</p>
<h5><a class="toc-backref" href="#id31">7.2.4.3&nbsp;&nbsp;&nbsp;Subtypes with Vnc suffix</a></h5>
<p>Authentication continues with the <a class="reference internal" href="#vnc-authentication">VNC Authentication</a> method when
TLS handshake is completed.</p>
<h5><a class="toc-backref" href="#id32">7.2.4.4&nbsp;&nbsp;&nbsp;Plain subtype</a></h5>
<p>Client sends the username and password in the following form:</p>
<table class="docutils">
<colgroup>
<col width="24%" />
<col width="18%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>username-length</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>password-length</em></td>
</tr>
<tr><td><em>username-length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>username</em></td>
</tr>
<tr><td><em>password-length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>password</em></td>
</tr>
</tbody>
</table>
<p>After that server verifies if supplied credentials are correct and
continues with the <a class="reference internal" href="#securityresult">SecurityResult</a> message.</p>
<h5><a class="toc-backref" href="#id33">7.2.4.5&nbsp;&nbsp;&nbsp;Subtypes with Plain suffix</a></h5>
<p>Authentication continues with the <a class="reference internal" href="#plain-subtype">Plain subtype</a> method when TLS handshake
is completed.</p>
<h5><a class="toc-backref" href="#id34">7.2.4.6&nbsp;&nbsp;&nbsp;Subtypes with SASL suffix</a></h5>
<p>Authentication continues with the SASL method when TLS handshake is completed.</p>
<h3><a class="toc-backref" href="#id35">7.3&nbsp;&nbsp;&nbsp;Initialisation Messages</a></h3>
<p>Once the client and server are sure that they're happy to talk to one
another using the agreed security type, the protocol passes to the
initialisation phase. The client sends a <em>ClientInit</em> message followed
by the server sending a <em>ServerInit</em> message.</p>
<h4><a class="toc-backref" href="#id36">7.3.1&nbsp;&nbsp;&nbsp;ClientInit</a></h4>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>shared-flag</em></td>
</tr>
</tbody>
</table>
<p><em>Shared-flag</em> is non-zero (true) if the server should try to share the
desktop by leaving other clients connected, zero (false) if it should
give exclusive access to this client by disconnecting all other
clients.</p>
<h4><a class="toc-backref" href="#id37">7.3.2&nbsp;&nbsp;&nbsp;ServerInit</a></h4>
<p>After receiving the <em>ClientInit</em> message, the server sends a
<em>ServerInit</em> message. This tells the client the width and height of the
server's framebuffer, its pixel format and the name associated with the
desktop:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>framebuffer-width</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>framebuffer-height</em></td>
</tr>
<tr><td>16</td>
<td><tt class="docutils literal">PIXEL_FORMAT</tt></td>
<td><em>server-pixel-format</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>name-length</em></td>
</tr>
<tr><td><em>name-length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>name-string</em></td>
</tr>
</tbody>
</table>
<p>The text encoding used for <em>name-string</em> is historically undefined but
it is strongly recommended to use UTF-8 (see <a class="reference internal" href="#string-encodings">String Encodings</a> for
more details).</p>
<p><tt class="docutils literal">PIXEL_FORMAT</tt> is defined as:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>bits-per-pixel</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>depth</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>big-endian-flag</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>true-colour-flag</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>red-max</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>green-max</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>blue-max</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>red-shift</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>green-shift</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>blue-shift</em></td>
</tr>
<tr><td>3</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
</tbody>
</table>
<p><em>Server-pixel-format</em> specifies the server's natural pixel format. This
pixel format will be used unless the client requests a different format
using the <em>SetPixelFormat</em> message (<a class="reference internal" href="#setpixelformat">SetPixelFormat</a>).</p>
<p><em>Bits-per-pixel</em> is the number of bits used for each pixel value on the
wire. This must be greater than or equal to the depth which is the
number of useful bits in the pixel value. Currently <em>bits-per-pixel</em>
must be 8, 16 or 32. Less than 8-bit pixels are not yet supported.
<em>Big-endian-flag</em> is non-zero (true) if multi-byte pixels are
interpreted as big endian. Of course this is meaningless for 8
bits-per-pixel.</p>
<p>If <em>true-colour-flag</em> is non-zero (true) then the last six items
specify how to extract the red, green and blue intensities from the
pixel value. <em>Red-max</em> is the maximum red value (= 2^n - 1 where <em>n</em> is
the number of bits used for red). Note this value is always in big
endian order. <em>Red-shift</em> is the number of shifts needed to get the red
value in a pixel to the least significant bit. <em>Green-max</em>,
<em>green-shift</em> and <em>blue-max</em>, <em>blue-shift</em> are similar for green and
blue. For example, to find the red value (between 0 and <em>red-max</em>) from
a given pixel, do the following:</p>
<ul class="simple">
<li>Swap the pixel value according to <em>big-endian-flag</em> (e.g. if
<em>big-endian-flag</em> is zero (false) and host byte order is big endian,
then swap).</li>
<li>Shift right by <em>red-shift</em>.</li>
<li>AND with <em>red-max</em> (in host byte order).</li>
</ul>
<p>If <em>true-colour-flag</em> is zero (false) then the server uses pixel values
which are not directly composed from the red, green and blue
intensities, but which serve as indices into a colour map. Entries in
the colour map are set by the server using the <em>SetColourMapEntries</em>
message (<a class="reference internal" href="#setcolourmapentries">SetColourMapEntries</a>).</p>
<p>If the <a class="reference internal" href="#tight-security-type">Tight Security Type</a> is activated, the server init message is
extended with an interaction capabilities section:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="16%" />
<col width="15%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>number-of-server-messages</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>number-of-client-messages</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>number-of-encodings</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>0</td>
<td><em>padding</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-server-messages</em> repetitions of the following:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>16</td>
<td><tt class="docutils literal">CAPABILITY</tt></td>
<td><em>server-message</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-client-messages</em> repetitions of the following:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>16</td>
<td><tt class="docutils literal">CAPABILITY</tt></td>
<td><em>client-message</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-encodings</em> repetitions of the following:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>16</td>
<td><tt class="docutils literal">CAPABILITY</tt></td>
<td><em>encoding</em></td>
</tr>
</tbody>
</table>
<p>The following <em>server-message</em> capabilities are registered:</p>
<table class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="22%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Code</th>
<th class="head">Vendor</th>
<th class="head">Signature</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>130</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTS_LSDT</tt>&quot;</td>
<td>File List Data</td>
</tr>
<tr><td>131</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTS_DNDT</tt>&quot;</td>
<td>File Download Data</td>
</tr>
<tr><td>132</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTS_UPCN</tt>&quot;</td>
<td>File Upload Cancel</td>
</tr>
<tr><td>133</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTS_DNFL</tt>&quot;</td>
<td>File Download Failed</td>
</tr>
<tr><td>150</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">CUS_EOCU</tt>&quot;</td>
<td>End Of Continuous Updates</td>
</tr>
<tr><td>253</td>
<td>&quot;<tt class="docutils literal">GGI_</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">GII_SERV</tt>&quot;</td>
<td><a class="reference internal" href="#gii-server-message">gii Server Message</a></td>
</tr>
</tbody>
</table>
<p>The following <em>client-message</em> capabilities are registered:</p>
<table class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="22%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Code</th>
<th class="head">Vendor</th>
<th class="head">Signature</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>130</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTC_LSRQ</tt>&quot;</td>
<td>File List Request</td>
</tr>
<tr><td>131</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTC_DNRQ</tt>&quot;</td>
<td>File Download Request</td>
</tr>
<tr><td>132</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTC_UPRQ</tt>&quot;</td>
<td>File Upload Request</td>
</tr>
<tr><td>133</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTC_UPDT</tt>&quot;</td>
<td>File Upload Data</td>
</tr>
<tr><td>134</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTC_DNCN</tt>&quot;</td>
<td>File Download Cancel</td>
</tr>
<tr><td>135</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTC_UPFL</tt>&quot;</td>
<td>File Upload Failed</td>
</tr>
<tr><td>136</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FTC_FCDR</tt>&quot;</td>
<td>File Create Directory Request</td>
</tr>
<tr><td>150</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">CUC_ENCU</tt>&quot;</td>
<td>Enable/Disable Continuous Updates</td>
</tr>
<tr><td>151</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">VRECTSEL</tt>&quot;</td>
<td>Video Rectangle Selection</td>
</tr>
<tr><td>253</td>
<td>&quot;<tt class="docutils literal">GGI_</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">GII_CLNT</tt>&quot;</td>
<td><a class="reference internal" href="#gii-client-message">gii Client Message</a></td>
</tr>
</tbody>
</table>
<p>The following <em>encoding</em> capabilities are registered:</p>
<table class="docutils">
<colgroup>
<col width="10%" />
<col width="16%" />
<col width="22%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Code</th>
<th class="head">Vendor</th>
<th class="head">Signature</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>&quot;<tt class="docutils literal">STDV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">RAW_____</tt>&quot;</td>
<td><a class="reference internal" href="#raw-encoding">Raw Encoding</a></td>
</tr>
<tr><td>1</td>
<td>&quot;<tt class="docutils literal">STDV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">COPYRECT</tt>&quot;</td>
<td><a class="reference internal" href="#copyrect-encoding">CopyRect Encoding</a></td>
</tr>
<tr><td>2</td>
<td>&quot;<tt class="docutils literal">STDV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">RRE_____</tt>&quot;</td>
<td><a class="reference internal" href="#rre-encoding">RRE Encoding</a></td>
</tr>
<tr><td>4</td>
<td>&quot;<tt class="docutils literal">STDV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">CORRE___</tt>&quot;</td>
<td><a class="reference internal" href="#corre-encoding">CoRRE Encoding</a></td>
</tr>
<tr><td>5</td>
<td>&quot;<tt class="docutils literal">STDV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">HEXTILE_</tt>&quot;</td>
<td><a class="reference internal" href="#hextile-encoding">Hextile Encoding</a></td>
</tr>
<tr><td>6</td>
<td>&quot;<tt class="docutils literal">TRDV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">ZLIB____</tt>&quot;</td>
<td><a class="reference internal" href="#zlib-encoding">ZLib Encoding</a></td>
</tr>
<tr><td>7</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">TIGHT___</tt>&quot;</td>
<td><a class="reference internal" href="#tight-encoding">Tight Encoding</a></td>
</tr>
<tr><td>8</td>
<td>&quot;<tt class="docutils literal">TRDV</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">ZLIBHEX_</tt>&quot;</td>
<td><a class="reference internal" href="#zlibhex-encoding">ZLibHex Encoding</a></td>
</tr>
<tr><td>-32</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">JPEGQLVL</tt>&quot;</td>
<td><a class="reference internal" href="#jpeg-quality-level-pseudo-encoding">JPEG Quality Level
Pseudo-encoding</a></td>
</tr>
<tr><td>-223</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">NEWFBSIZ</tt>&quot;</td>
<td><a class="reference internal" href="#desktopsize-pseudo-encoding">DesktopSize Pseudo-encoding</a> (New
FB Size)</td>
</tr>
<tr><td>-224</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">LASTRECT</tt>&quot;</td>
<td><a class="reference internal" href="#lastrect-pseudo-encoding">LastRect Pseudo-encoding</a></td>
</tr>
<tr><td>-232</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">POINTPOS</tt>&quot;</td>
<td>Pointer Position</td>
</tr>
<tr><td>-239</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">RCHCURSR</tt>&quot;</td>
<td><a class="reference internal" href="#cursor-pseudo-encoding">Cursor Pseudo-encoding</a> (Rich
Cursor)</td>
</tr>
<tr><td>-240</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">X11CURSR</tt>&quot;</td>
<td><a class="reference internal" href="#x-cursor-pseudo-encoding">X Cursor Pseudo-encoding</a></td>
</tr>
<tr><td>-256</td>
<td>&quot;<tt class="docutils literal">TGHT</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">COMPRLVL</tt>&quot;</td>
<td><a class="reference internal" href="#compression-level-pseudo-encoding">Compression Level
Pseudo-encoding</a></td>
</tr>
<tr><td>-305</td>
<td>&quot;<tt class="docutils literal">GGI_</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">GII_____</tt>&quot;</td>
<td><a class="reference internal" href="#gii-pseudo-encoding">gii Pseudo-encoding</a></td>
</tr>
<tr><td>-512</td>
<td>&quot;<tt class="docutils literal">TRBO</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">FINEQLVL</tt>&quot;</td>
<td><a class="reference internal" href="#jpeg-fine-grained-quality-level-pseudo-encoding">JPEG Fine-Grained Quality Level
Pseudo-encoding</a></td>
</tr>
<tr><td>-768</td>
<td>&quot;<tt class="docutils literal">TRBO</tt>&quot;</td>
<td>&quot;<tt class="docutils literal">SSAMPLVL</tt>&quot;</td>
<td><a class="reference internal" href="#jpeg-subsampling-level-pseudo-encoding">JPEG Subsampling Level
Pseudo-encoding</a></td>
</tr>
</tbody>
</table>
<p>Note that the server need not (but it may) list the &quot;<tt class="docutils literal">RAW_____</tt>&quot;
capability since it must be supported anyway.</p>
<h3><a class="toc-backref" href="#id38">7.4&nbsp;&nbsp;&nbsp;Client to Server Messages</a></h3>
<p>The client to server message types that all servers must support are:</p>
<table class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Number</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td><a class="reference internal" href="#setpixelformat">SetPixelFormat</a></td>
</tr>
<tr><td>2</td>
<td><a class="reference internal" href="#setencodings">SetEncodings</a></td>
</tr>
<tr><td>3</td>
<td><a class="reference internal" href="#framebufferupdaterequest">FramebufferUpdateRequest</a></td>
</tr>
<tr><td>4</td>
<td><a class="reference internal" href="#keyevent">KeyEvent</a></td>
</tr>
<tr><td>5</td>
<td><a class="reference internal" href="#pointerevent">PointerEvent</a></td>
</tr>
<tr><td>6</td>
<td><a class="reference internal" href="#clientcuttext">ClientCutText</a></td>
</tr>
</tbody>
</table>
<p>Optional message types are:</p>
<table class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Number</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>7</td>
<td>FileTransfer</td>
</tr>
<tr><td>8</td>
<td>SetScale</td>
</tr>
<tr><td>9</td>
<td>SetServerInput</td>
</tr>
<tr><td>10</td>
<td>SetSW</td>
</tr>
<tr><td>11</td>
<td>TextChat</td>
</tr>
<tr><td>12</td>
<td>KeyFrameRequest</td>
</tr>
<tr><td>13</td>
<td>KeepAlive</td>
</tr>
<tr><td>14</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr><td>15</td>
<td>SetScaleFactor</td>
</tr>
<tr><td>16-19</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr><td>20</td>
<td>RequestSession</td>
</tr>
<tr><td>21</td>
<td>SetSession</td>
</tr>
<tr><td>80</td>
<td>NotifyPluginStreaming</td>
</tr>
<tr><td>127</td>
<td>VMWare</td>
</tr>
<tr><td>128</td>
<td>Car Connectivity</td>
</tr>
<tr><td>150</td>
<td><a class="reference internal" href="#enablecontinuousupdates">EnableContinuousUpdates</a></td>
</tr>
<tr><td>248</td>
<td><a class="reference internal" href="#clientfence">ClientFence</a></td>
</tr>
<tr><td>249</td>
<td>OLIVE Call Control</td>
</tr>
<tr><td>250</td>
<td><a class="reference internal" href="#xvp-client-message">xvp Client Message</a></td>
</tr>
<tr><td>251</td>
<td><a class="reference internal" href="#setdesktopsize">SetDesktopSize</a></td>
</tr>
<tr><td>252</td>
<td>tight</td>
</tr>
<tr><td>253</td>
<td><a class="reference internal" href="#gii-client-message">gii Client Message</a></td>
</tr>
<tr><td>254</td>
<td>VMWare</td>
</tr>
<tr><td>255</td>
<td><a class="reference internal" href="#qemu-client-message">QEMU Client Message</a></td>
</tr>
</tbody>
</table>
<p>The official, up-to-date list is maintained by IANA <a class="footnote-reference" href="#reg" id="id4">[1]</a>.</p>
<p>Note that before sending a message with an optional message type a
client must have determined that the server supports the relevant
extension by receiving some extension-specific confirmation from the
server.</p>
<h4><a class="toc-backref" href="#id39">7.4.1&nbsp;&nbsp;&nbsp;SetPixelFormat</a></h4>
<p>Sets the format in which pixel values should be sent in
<em>FramebufferUpdate</em> messages. If the client does not send a
<em>SetPixelFormat</em> message then the server sends pixel values in its
natural format as specified in the ServerInit message (<a class="reference internal" href="#serverinit">ServerInit</a>).</p>
<p>If <em>true-colour-flag</em> is zero (false) then this indicates that a
&quot;colour map&quot; is to be used. The server can set any of the entries in
the colour map using the <em>SetColourMapEntries</em> message
(<a class="reference internal" href="#setcolourmapentries">SetColourMapEntries</a>). Immediately after the client has sent this
message the colour map is empty, even if entries had previously been
set by the server.</p>
<p>Note that a client must not have an outstanding
<em>FramebufferUpdateRequest</em> when it sends <em>SetPixelFormat</em> as it would
be impossible to determine if the next <em>FramebufferUpdate</em> is using the
new or the previous pixel format.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>0</td>
<td><em>message-type</em></td>
</tr>
<tr><td>3</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>16</td>
<td><tt class="docutils literal">PIXEL_FORMAT</tt></td>
<td>&nbsp;</td>
<td><em>pixel-format</em></td>
</tr>
</tbody>
</table>
<p>where <tt class="docutils literal">PIXEL_FORMAT</tt> is as described in <a class="reference internal" href="#serverinit">ServerInit</a>:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>bits-per-pixel</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>depth</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>big-endian-flag</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>true-colour-flag</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>red-max</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>green-max</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>blue-max</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>red-shift</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>green-shift</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>blue-shift</em></td>
</tr>
<tr><td>3</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id40">7.4.2&nbsp;&nbsp;&nbsp;SetEncodings</a></h4>
<p>Sets the encoding types in which pixel data can be sent by the server.
The order of the encoding types given in this message is a hint by the
client as to its preference (the first encoding specified being most
preferred). The server may or may not choose to make use of this hint.
Pixel data may always be sent in <em>raw</em> encoding even if not specified
explicitly here.</p>
<p>In addition to genuine encodings, a client can request
&quot;pseudo-encodings&quot; to declare to the server that it supports certain
extensions to the protocol. A server which does not support the
extension will simply ignore the pseudo-encoding. Note that this means
the client must assume that the server does not support the extension
until it gets some extension-specific confirmation from the server.</p>
<p>See <a class="reference internal" href="#encodings">Encodings</a> for a description of each encoding and
<a class="reference internal" href="#pseudo-encodings">Pseudo-encodings</a> for the meaning of pseudo-encodings.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>2</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>number-of-encodings</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-encodings</em> repetitions of the following:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">S32</tt></td>
<td><em>encoding-type</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id41">7.4.3&nbsp;&nbsp;&nbsp;FramebufferUpdateRequest</a></h4>
<p>Notifies the server that the client is interested in the area of the
framebuffer specified by <em>x-position</em>, <em>y-position</em>, <em>width</em> and
<em>height</em>. The server usually responds to a <em>FramebufferUpdateRequest</em>
by sending a <em>FramebufferUpdate</em>. Note however that a single
<em>FramebufferUpdate</em> may be sent in reply to several
<em>FramebufferUpdateRequests</em>.</p>
<p>The server assumes that the client keeps a copy of all parts of the
framebuffer in which it is interested. This means that normally the
server only needs to send incremental updates to the client.</p>
<p>However, if for some reason the client has lost the contents of a
particular area which it needs, then the client sends a
<em>FramebufferUpdateRequest</em> with <em>incremental</em> set to zero (false). This
requests that the server send the entire contents of the specified area
as soon as possible. The area will not be updated using the <em>CopyRect</em>
encoding.</p>
<p>If the client has not lost any contents of the area in which it is
interested, then it sends a <em>FramebufferUpdateRequest</em> with
<em>incremental</em> set to non-zero (true). If and when there are changes to
the specified area of the framebuffer, the server will send a
<em>FramebufferUpdate</em>. Note that there may be an indefinite period
between the <em>FramebufferUpdateRequest</em> and the <em>FramebufferUpdate</em>.</p>
<p>In the case of a fast client, the client may want to regulate the rate
at which it sends incremental <em>FramebufferUpdateRequests</em> to avoid
hogging the network.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>3</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>incremental</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>x-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>y-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>width</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>height</em></td>
</tr>
</tbody>
</table>
<p>A request for an area that partly falls outside the current framebuffer
must be cropped so that it fits within the framebuffer dimensions.</p>
<p>Note that an empty area can still solicit a <em>FramebufferUpdate</em> even
though that update will only contain pseudo-encodings.</p>
<h4><a class="toc-backref" href="#id42">7.4.4&nbsp;&nbsp;&nbsp;KeyEvent</a></h4>
<p>A key press or release. <em>Down-flag</em> is non-zero (true) if the key is
now pressed, zero (false) if it is now released. The key itself is
specified using the &quot;keysym&quot; values defined by the X Window System.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>4</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>down-flag</em></td>
</tr>
<tr><td>2</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td><em>key</em></td>
</tr>
</tbody>
</table>
<p>Auto repeating of keys when a key is held down should be handled on the
client. The rationale being that high latency on the network can make
it seem like a key is being held for a very long time, yet the problem
is that the <em>KeyEvent</em> message releasing the button has been delayed.</p>
<p>The client should send only repeated &quot;down&quot; <em>KeyEvent</em> messages, no
&quot;up&quot; messages, when a key is automatically repeated. This allows the
server to tell the difference between automatic repeat and actual
repeated entry by the user.</p>
<p>For most ordinary keys, the &quot;keysym&quot; is the same as the corresponding
ASCII value. For full details, see The Xlib Reference Manual, published
by O'Reilly &amp; Associates, or see the header file <tt class="docutils literal">&lt;X11/keysymdef.h&gt;</tt>
from any X Window System installation. Some other common keys are:</p>
<table class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Key name</th>
<th class="head">Keysym value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>BackSpace</td>
<td>0xff08</td>
</tr>
<tr><td>Tab</td>
<td>0xff09</td>
</tr>
<tr><td>Return or Enter</td>
<td>0xff0d</td>
</tr>
<tr><td>Escape</td>
<td>0xff1b</td>
</tr>
<tr><td>Insert</td>
<td>0xff63</td>
</tr>
<tr><td>Delete</td>
<td>0xffff</td>
</tr>
<tr><td>Home</td>
<td>0xff50</td>
</tr>
<tr><td>End</td>
<td>0xff57</td>
</tr>
<tr><td>Page Up</td>
<td>0xff55</td>
</tr>
<tr><td>Page Down</td>
<td>0xff56</td>
</tr>
<tr><td>Left</td>
<td>0xff51</td>
</tr>
<tr><td>Up</td>
<td>0xff52</td>
</tr>
<tr><td>Right</td>
<td>0xff53</td>
</tr>
<tr><td>Down</td>
<td>0xff54</td>
</tr>
<tr><td>F1</td>
<td>0xffbe</td>
</tr>
<tr><td>F2</td>
<td>0xffbf</td>
</tr>
<tr><td>F3</td>
<td>0xffc0</td>
</tr>
<tr><td>F4</td>
<td>0xffc1</td>
</tr>
<tr><td>...</td>
<td>...</td>
</tr>
<tr><td>F12</td>
<td>0xffc9</td>
</tr>
<tr><td>Shift (left)</td>
<td>0xffe1</td>
</tr>
<tr><td>Shift (right)</td>
<td>0xffe2</td>
</tr>
<tr><td>Control (left)</td>
<td>0xffe3</td>
</tr>
<tr><td>Control (right)</td>
<td>0xffe4</td>
</tr>
<tr><td>Meta (left)</td>
<td>0xffe7</td>
</tr>
<tr><td>Meta (right)</td>
<td>0xffe8</td>
</tr>
<tr><td>Alt (left)</td>
<td>0xffe9</td>
</tr>
<tr><td>Alt (right)</td>
<td>0xffea</td>
</tr>
</tbody>
</table>
<p>The interpretation of keysyms is a complex area. In order to be as
widely interoperable as possible the following guidelines should be
used:</p>
<ul class="simple">
<li>The &quot;shift state&quot; (i.e. whether either of the Shift keysyms are down)
should only be used as a hint when interpreting a keysym. For
example, on a US keyboard the '#' character is shifted, but on a UK
keyboard it is not. A server with a US keyboard receiving a '#'
character from a client with a UK keyboard will not have been sent
any shift presses. In this case, it is likely that the server will
internally need to &quot;fake&quot; a shift press on its local system, in order
to get a '#' character and not, for example, a '3'.</li>
<li>The difference between upper and lower case keysyms is significant.
This is unlike some of the keyboard processing in the X Window System
which treats them as the same. For example, a server receiving an
uppercase 'A' keysym without any shift presses should interpret it as
an uppercase 'A'. Again this may involve an internal &quot;fake&quot; shift
press.</li>
<li>Servers should ignore &quot;lock&quot; keysyms such as CapsLock and NumLock
where possible. Instead they should interpret each character-based
keysym according to its case.</li>
<li>Unlike Shift, the state of modifier keys such as Control and Alt
should be taken as modifying the interpretation of other keysyms.
Note that there are no keysyms for ASCII control characters such as
ctrl-a; these should be generated by viewers sending a Control press
followed by an 'a' press.</li>
<li>On a viewer where modifiers like Control and Alt can also be used to
generate character-based keysyms, the viewer may need to send extra
&quot;release&quot; events in order that the keysym is interpreted correctly.
For example, on a German PC keyboard, ctrl-alt-q generates the '&#64;'
character. In this case, the viewer needs to send &quot;fake&quot; release
events for Control and Alt in order that the '&#64;' character is
interpreted correctly (ctrl-alt-&#64; is likely to mean something
completely different to the server).</li>
<li>There is no universal standard for &quot;backward tab&quot; in the X Window
System. On some systems shift+tab gives the keysym &quot;ISO Left Tab&quot;, on
others it gives a private &quot;BackTab&quot; keysym and on others it gives
&quot;Tab&quot; and applications tell from the shift state that it means
backward-tab rather than forward-tab. In the RFB protocol the latter
approach is preferred. Viewers should generate a shifted Tab rather
than ISO Left Tab. However, to be backwards-compatible with existing
viewers, servers should also recognise ISO Left Tab as meaning a
shifted Tab.</li>
</ul>
<h4><a class="toc-backref" href="#id43">7.4.5&nbsp;&nbsp;&nbsp;PointerEvent</a></h4>
<p>Indicates either pointer movement or a pointer button press or release.
The pointer is now at (<em>x-position</em>, <em>y-position</em>), and the current
state of buttons 1 to 8 are represented by bits 0 to 7 of <em>button-mask</em>
respectively, 0 meaning up, 1 meaning down (pressed).</p>
<p>On a conventional mouse, buttons 1, 2 and 3 correspond to the left,
middle and right buttons on the mouse. On a wheel mouse, each step of
the wheel is represented by a press and release of a certain button.
Button 4 means up, button 5 means down, button 6 means left and
button 7 means right.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>5</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>button-mask</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>x-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>y-position</em></td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="#qemu-pointer-motion-change-psuedo-encoding">QEMU Pointer Motion Change Psuedo-encoding</a> allows for the
negotiation of an alternative interpretation for the <em>x-position</em>
and <em>y-position</em> fields, as relative deltas.</p>
<h4><a class="toc-backref" href="#id44">7.4.6&nbsp;&nbsp;&nbsp;ClientCutText</a></h4>
<p>The client has new ISO 8859-1 (Latin-1) text in its cut buffer. Ends of
lines are represented by the linefeed / newline character (value 10)
alone. No carriage-return (value 13) is needed. There is currently no
way to transfer text outside the Latin-1 character set.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>6</td>
<td><em>message-type</em></td>
</tr>
<tr><td>3</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td><em>length</em></td>
</tr>
<tr><td><em>length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>&nbsp;</td>
<td><em>text</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id45">7.4.7&nbsp;&nbsp;&nbsp;EnableContinuousUpdates</a></h4>
<p>This message informs the server to switch between only sending
<a class="reference internal" href="#framebufferupdate">FramebufferUpdate</a> messages as a result of a
<a class="reference internal" href="#framebufferupdaterequest">FramebufferUpdateRequest</a> message, or sending <tt class="docutils literal">FramebufferUpdate</tt>
messages continuously.</p>
<p>Note that there is currently no way to determine if the server supports
this message except for using the <a class="reference internal" href="#tight-security-type">Tight Security Type</a> authentication.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>150</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>enable-flag</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>x-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>y-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>width</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>height</em></td>
</tr>
</tbody>
</table>
<p>If <em>enable-flag</em> is non-zero, then the server can start sending
<tt class="docutils literal">FramebufferUpdate</tt> messages as needed for the area specified by
<em>x-position</em>, <em>y-position</em>, <em>width</em>, and <em>height</em>. If continuous
updates are already active, then they must remain active active and the
coordinates must be replaced with the last message seen.</p>
<p>If <em>enable-flag</em> is zero, then the server must only send
<tt class="docutils literal">FramebufferUpdate</tt> messages as a result of receiving
<tt class="docutils literal">FramebufferUpdateRequest</tt> messages. The server must also immediately
send out a <a class="reference internal" href="#endofcontinuousupdates">EndOfContinuousUpdates</a> message. This message must be sent
out even if continuous updates were already disabled.</p>
<p>The server must ignore all incremental update requests
(<tt class="docutils literal">FramebufferUpdateRequest</tt> with <em>incremental</em> set to non-zero) as
long as continuous updates are active. Non-incremental updates must
however be honored, even if the area in such a request does not overlap
the area specified for continuous updates.</p>
<h4><a class="toc-backref" href="#id46">7.4.8&nbsp;&nbsp;&nbsp;ClientFence</a></h4>
<p>A client supporting the <em>Fence</em> extension sends this to request a
synchronisation of the data stream.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>248</td>
<td><em>message-type</em></td>
</tr>
<tr><td>3</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td><em>flags</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>length</em></td>
</tr>
<tr><td><em>length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>&nbsp;</td>
<td><em>payload</em></td>
</tr>
</tbody>
</table>
<p>The <em>flags</em> byte informs the server if this is a new request, or a
response to a server request sent earlier, as well as what kind of
synchronisation that is desired. The server should not delay the
response more than necessary, even if the synchronisation requirements
would allow it.</p>
<table class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Bit</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td><strong>BlockBefore</strong></td>
</tr>
<tr><td>1</td>
<td><strong>BlockAfter</strong></td>
</tr>
<tr><td>2</td>
<td><strong>SyncNext</strong></td>
</tr>
<tr><td>3-30</td>
<td>Currently unused</td>
</tr>
<tr><td>31</td>
<td><strong>Request</strong></td>
</tr>
</tbody>
</table>
<p>The server should respond with a <a class="reference internal" href="#serverfence">ServerFence</a> with the <strong>Request</strong>
bit cleared, as well as clearing any bits it does not understand. The
remaining bits should remain set in the response. This allows the
client to determine which flags the server supports when new ones are
defined in the future.</p>
<dl class="docutils">
<dt><strong>BlockBefore</strong></dt>
<dd>All messages preceeding this one must have finished processing and
taken effect before the response is sent.</dd>
<dt><strong>BlockAfter</strong></dt>
<dd>All messages following this one must not start processing until the
response is sent.</dd>
<dt><strong>SyncNext</strong></dt>
<dd><p class="first">The message following this one must be executed in an atomic manner
so that anything preceeding the fence response <strong>must not</strong> be
affected by the message, and anything following the fence response
<em>must</em> be affected by the message. The primary purpose of this
synchronisation is to allow safe usage of stream altering commands
such as <a class="reference internal" href="#setpixelformat">SetPixelFormat</a>.</p>
<p class="last">If <strong>BlockAfter</strong> is set then that synchronisation must be relaxed
to allow processing of the following message. Any message after
that will still be affected by both flags though.</p>
</dd>
<dt><strong>Request</strong></dt>
<dd>Indicates that this is a new request and that a response is
expected. If this bit is cleared then this message is a response to
an earlier request.</dd>
</dl>
<p>The client can also include a chunk of data to differentiate between
responses and to avoid keeping state. This data is specified using
<em>length</em> and <em>payload</em>. The size of this data is limited to 64 bytes in
order to minimise the disturbance to highly parallel clients and
servers.</p>
<h4><a class="toc-backref" href="#id47">7.4.9&nbsp;&nbsp;&nbsp;xvp Client Message</a></h4>
<p>A client supporting the <em>xvp</em> extension sends this to request that the
server initiate a clean shutdown, clean reboot or abrupt reset of the
system whose framebuffer the client is displaying.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>250</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1</td>
<td><em>xvp-extension-version</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>xvp-message-code</em></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>xvp-message-code</em> are: 2 - XVP_SHUTDOWN,
3 - XVP_REBOOT, and 4 - XVP_RESET.  The client must have already
established that the server supports this extension, by requesting the
<a class="reference internal" href="#xvp-pseudo-encoding">xvp Pseudo-encoding</a>.</p>
<h4><a class="toc-backref" href="#id48">7.4.10&nbsp;&nbsp;&nbsp;SetDesktopSize</a></h4>
<p>Requests a change of desktop size. This message is an extension and
may only be sent if the client has previously received an
<em>ExtendedDesktopSize</em> rectangle.</p>
<p>The server must send an <em>ExtendedDesktopSize</em> rectangle for every
<em>SetDesktopSize</em> message received. Several rectangles may be
sent in a single <em>FramebufferUpdate</em> message, but the rectangles must
not be merged or reordered in any way. Note that rectangles sent for
other reasons may be interleaved with the ones generated as a result
of <em>SetDesktopSize</em> messages.</p>
<p>Upon a successful request the server must send an <em>ExtendedDesktopSize</em>
rectangle to the requesting client with the exact same information the
client provided in the corresponding <em>SetDesktopSize</em> message.
<em>x-position</em> must be set to 1, indicating a client initiated event, and
<em>y-position</em> must be set to 0, indicating success.</p>
<p>The server must also send an <em>ExtendedDesktopSize</em> rectangle to all
other connected clients, but with <em>x-position</em> set to 2, indicating a
change initiated by another client.</p>
<p>If the server can not or will not satisfy the request, it must send
an <em>ExtendedDesktopSize</em> rectangle to the requesting client with
<em>x-position</em> set to 1 and <em>y-position</em> set to the relevant error code.
All remaining fields are undefined, although the basic structure must
still be followed. The server must not send an <em>ExtendedDesktopSize</em>
rectangle to any other connected clients.</p>
<p>All <em>ExtendedDesktopSize</em> rectangles that are sent as a result of a
<em>SetDesktopSize</em> message should be sent as soon as possible.</p>
<table class="docutils">
<colgroup>
<col width="35%" />
<col width="25%" />
<col width="10%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>251</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>width</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>height</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>number-of-screens</em></td>
</tr>
<tr><td>1</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td><em>number-of-screens</em> * 16</td>
<td><tt class="docutils literal">SCREEN</tt> array</td>
<td>&nbsp;</td>
<td><em>screens</em></td>
</tr>
</tbody>
</table>
<p>The <em>width</em> and <em>height</em> indicates the framebuffer size requested. This
structure is followed by <em>number-of-screens</em> number of <tt class="docutils literal">SCREEN</tt>
structures, which is defined in <a class="reference internal" href="#extendeddesktopsize-pseudo-encoding">ExtendedDesktopSize Pseudo-encoding</a>:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>id</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>x-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>y-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>width</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>height</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>flags</em></td>
</tr>
</tbody>
</table>
<p>The <em>id</em> field must be preserved upon modification as it determines the
difference between a moved screen and a newly created one. The client
should make every effort to preserve the fields it does not wish to
modify, including any unknown <em>flags</em> bits.</p>
<h4><a class="toc-backref" href="#id49">7.4.11&nbsp;&nbsp;&nbsp;gii Client Message</a></h4>
<p>This message is an extension and may only be sent if the client has
previously received a <a class="reference internal" href="#gii-server-message">gii Server Message</a> confirming that the server
supports the General Input Interface extension.</p>
<h5><a class="toc-backref" href="#id50">7.4.11.1&nbsp;&nbsp;&nbsp;Version</a></h5>
<p>The client response to a <em>gii</em> Version message from the server is the
following response:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1 or 129</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>4</td>
<td><em>length</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>1</td>
<td><em>version</em></td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit indicating
big endian if set, and little endian if cleared. The rest of the bits
are the actual message sub type.</p>
<p><em>version</em> is set by the client and ultimately decides the version of
<em>gii</em> protocol extension to use. It should be in the range given by the
server in the <em>gii</em> Version message. If the server doesn't support any
version that the client supports, the client should instead stop using
the <em>gii</em> extension at this point.</p>
<h5><a class="toc-backref" href="#id51">7.4.11.2&nbsp;&nbsp;&nbsp;Device Creation</a></h5>
<p>After establishing the <em>gii</em> protocol extension version, the client
proceeds by requesting creation of one or more devices.</p>
<table class="docutils">
<colgroup>
<col width="31%" />
<col width="22%" />
<col width="15%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>2 or 130</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>2</td>
<td><em>length</em></td>
</tr>
<tr><td>31</td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>&nbsp;</td>
<td><em>device-name</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>0</td>
<td><em>nul-terminator</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>vendor-id</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>product-id</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EVENT_MASK</tt></td>
<td>&nbsp;</td>
<td><em>can-generate</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>num-registers</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>num-valuators</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>num-buttons</em></td>
</tr>
<tr><td><em>num-valuators</em> * 116</td>
<td><tt class="docutils literal">VALUATOR</tt></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit indicating
big endian if set, and little endian if cleared. The rest of the bits
are the actual message sub type.</p>
<p><tt class="docutils literal">EVENT_MASK</tt> is a bit-field indicating which events the device
can generate.</p>
<table class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Value</th>
<th class="head">Bit name</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0x00000020</td>
<td>Key press</td>
</tr>
<tr><td>0x00000040</td>
<td>Key release</td>
</tr>
<tr><td>0x00000080</td>
<td>Key repeat</td>
</tr>
<tr><td>0x00000100</td>
<td>Pointer relative</td>
</tr>
<tr><td>0x00000200</td>
<td>Pointer absolute</td>
</tr>
<tr><td>0x00000400</td>
<td>Pointer button press</td>
</tr>
<tr><td>0x00000800</td>
<td>Pointer button release</td>
</tr>
<tr><td>0x00001000</td>
<td>Valuator relative</td>
</tr>
<tr><td>0x00002000</td>
<td>Valuator absolute</td>
</tr>
</tbody>
</table>
<p>and <tt class="docutils literal">VALUATOR</tt> is</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>index</em></td>
</tr>
<tr><td>74</td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>&nbsp;</td>
<td><em>long-name</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>0</td>
<td><em>nul-terminator</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>&nbsp;</td>
<td><em>short-name</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>0</td>
<td><em>nul-terminator</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>range-min</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>range-center</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>range-max</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>SI-unit</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>SI-add</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>SI-mul</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>SI-div</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>SI-shift</em></td>
</tr>
</tbody>
</table>
<p>The <em>SI-unit</em> field is defined as:</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="29%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Number</th>
<th class="head">SI-unit</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>&nbsp;</td>
<td>unknown</td>
</tr>
<tr><td>1</td>
<td>s</td>
<td>time</td>
</tr>
<tr><td>2</td>
<td>1/s</td>
<td>frequency</td>
</tr>
<tr><td>3</td>
<td>m</td>
<td>length</td>
</tr>
<tr><td>4</td>
<td>m/s</td>
<td>velocity</td>
</tr>
<tr><td>5</td>
<td>m/s^2</td>
<td>acceleration</td>
</tr>
<tr><td>6</td>
<td>rad</td>
<td>angle</td>
</tr>
<tr><td>7</td>
<td>rad/s</td>
<td>angular velocity</td>
</tr>
<tr><td>8</td>
<td>rad/s^2</td>
<td>angular acceleration</td>
</tr>
<tr><td>9</td>
<td>m^2</td>
<td>area</td>
</tr>
<tr><td>10</td>
<td>m^3</td>
<td>volume</td>
</tr>
<tr><td>11</td>
<td>kg</td>
<td>mass</td>
</tr>
<tr><td>12</td>
<td>N (kg*m/s^2)</td>
<td>force</td>
</tr>
<tr><td>13</td>
<td>N/m^2 (Pa)</td>
<td>pressure</td>
</tr>
<tr><td>14</td>
<td>Nm</td>
<td>torque</td>
</tr>
<tr><td>15</td>
<td>Nm, VAs, J</td>
<td>energy</td>
</tr>
<tr><td>16</td>
<td>Nm/s, VA, W</td>
<td>power</td>
</tr>
<tr><td>17</td>
<td>K</td>
<td>temperature</td>
</tr>
<tr><td>18</td>
<td>A</td>
<td>current</td>
</tr>
<tr><td>19</td>
<td>V (kg*m^2/(As^3))</td>
<td>voltage</td>
</tr>
<tr><td>20</td>
<td>V/A (Ohm)</td>
<td>resistance</td>
</tr>
<tr><td>21</td>
<td>As/V</td>
<td>capacity</td>
</tr>
<tr><td>22</td>
<td>Vs/A</td>
<td>inductivity</td>
</tr>
</tbody>
</table>
<p>The <em>SI-add</em>, <em>SI-mul</em>, <em>SI-div</em> and <em>SI-shift</em> fields of the
<tt class="docutils literal">VALUATOR</tt> indicate how the raw value should be translated to the
SI-unit using the below formula.</p>
<blockquote>
float SI = (float) (SI_add + value[n]) * (float) SI_mul
/ (float) SI_div * pow(2.0, SI_shift);</blockquote>
<p>Setting <em>SI-mul</em> to zero indicates that the valuator is non-linear or
that the factor is unknown.</p>
<h5><a class="toc-backref" href="#id52">7.4.11.3&nbsp;&nbsp;&nbsp;Device Destruction</a></h5>
<p>The client can destroy a device with a device destruct message.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>3 or 131</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>4</td>
<td><em>length</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>device-origin</em></td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit indicating
big endian if set, and little endian if cleared. The rest of the bits
are the actual message sub type.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device creation
request.</p>
<h5><a class="toc-backref" href="#id53">7.4.11.4&nbsp;&nbsp;&nbsp;Injecting Events</a></h5>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>0 or 128</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>&nbsp;</td>
<td><em>length</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>length</em> bytes of <tt class="docutils literal">EVENT</tt> entries</p>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit indicating
big endian if set, and little endian if cleared. The rest of the bits
are the actual message sub type.</p>
<p><tt class="docutils literal">EVENT</tt> is one of <tt class="docutils literal">KEY_EVENT</tt>, <tt class="docutils literal">PTR_MOVE_EVENT</tt>,
<tt class="docutils literal">PTR_BUTTON_EVENT</tt> and <tt class="docutils literal">VALUATOR_EVENT</tt>.</p>
<p><tt class="docutils literal">KEY_EVENT</tt> is:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>24</td>
<td><em>event-size</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>5, 6 or 7</td>
<td><em>event-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>device-origin</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>modifiers</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>symbol</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>label</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>button</em></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>event-type</em> are: 5 - key pressed, 6 - key
released and 7 - key repeat. XXX describe <em>modifiers</em>, <em>symbol</em>,
<em>label</em> and <em>button</em>. Meanwhile, see
<a class="reference external" href="http://www.ggi-project.org/documentation/libgii/current/gii_key_event.3.html">http://www.ggi-project.org/documentation/libgii/current/gii_key_event.3.html</a>
for details.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device creation
request.</p>
<p><tt class="docutils literal">PTR_MOVE_EVENT</tt> is:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>24</td>
<td><em>event-size</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>8 or 9</td>
<td><em>event-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>device-origin</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>x</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>y</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>z</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">ES32</tt></td>
<td>&nbsp;</td>
<td><em>wheel</em></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>event-type</em> are: 8 - pointer relative and
9 - pointer absolute.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device creation
request.</p>
<p><tt class="docutils literal">PTR_BUTTON_EVENT</tt> is:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>12</td>
<td><em>event-size</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>10 or 11</td>
<td><em>event-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>device-origin</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>button-number</em></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>event-type</em> are: 10 - pointer button press and
11 - pointer button release.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device creation
request.</p>
<p><em>button-number</em> 1 is the primary or left button, <em>button-number</em> 2 is
the secondary or right button and <em>button-number</em> 3 is the tertiary or
middle button. Other values for <em>button-number</em> are also valid.</p>
<p><tt class="docutils literal">VALUATOR_EVENT</tt> is:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="25%" />
<col width="26%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>16 + 4 * <em>count</em></td>
<td><em>event-size</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>12 or 13</td>
<td><em>event-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>device-origin</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>first</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>count</em></td>
</tr>
<tr><td>4 * <em>count</em></td>
<td><tt class="docutils literal">ES32</tt> array</td>
<td>&nbsp;</td>
<td><em>value</em></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>event-type</em> are: 12 - relative valuator and
13 - absolute valuator.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device creation
request.</p>
<p>The event reports <em>count</em> valuators starting with <em>first</em>.</p>
<h4><a class="toc-backref" href="#id54">7.4.12&nbsp;&nbsp;&nbsp;QEMU Client Message</a></h4>
<p>This message may only be sent if the client has previously received
a <em>FrameBufferUpdate</em> that confirms support for the intended
<em>submessage-type</em>. Every <tt class="docutils literal">QEMU Client Message</tt> begins with
a standard header</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>submessage-type</em></td>
</tr>
</tbody>
</table>
<p>This header is then followed by arbitrary data whose format is
determined by the <em>submessage-type</em>. Possible values for
<em>submessage-type</em> and their associated psuedo encodings are</p>
<table class="docutils">
<colgroup>
<col width="31%" />
<col width="31%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Submessage Type</th>
<th class="head">Psuedo Encoding</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>-258</td>
<td>Extended key events</td>
</tr>
<tr><td>1</td>
<td>-259</td>
<td>Audio</td>
</tr>
</tbody>
</table>
<h5><a class="toc-backref" href="#id55">7.4.12.1&nbsp;&nbsp;&nbsp;QEMU Extended Key Event Message</a></h5>
<p>This submessage allows the client to send an extended key event
containing a keycode, in addition to a keysym. The advantage of
providing the keycode is that it enables the server to interpret
the key event independantly of the clients' locale specific
keymap. This can be important for virtual desktops whose key
input device requires scancodes, for example, virtual machines
emulating a PS/2 keycode. Prior to this extension, RFB servers
for such virtualization software would have to be configured
with a keymap matching the client. With this extension it is
sufficient for the guest operating system to be configured with
the matching keymap. The VNC server is keymap independant.</p>
<p>The full message is:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>0</td>
<td><em>submessage-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>down-flag</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td><em>keysym</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td><em>keycode</em></td>
</tr>
</tbody>
</table>
<p>The <em>keysym</em> and <em>down-flag</em> fields also take the same values as
described for the <a class="reference internal" href="#keyevent">KeyEvent</a> message. Auto repeating behaviour
of keys is also as described for the <a class="reference internal" href="#keyevent">KeyEvent</a> message.</p>
<p>The <em>keycode</em> is the XT keycode that produced the <em>keysym</em>. An
XT keycode is an XT make scancode sequence encoded to fit in
a single <tt class="docutils literal">U32</tt> quantity. Single byte XT scancodes with a byte
value less than 0x7f are encoded as is. 2-byte XT scancodes
whose first byte is 0xe0 and second byte is less than 0x7f are
encoded with the high bit of the first byte set. Some example
mappings are</p>
<table class="docutils">
<colgroup>
<col width="25%" />
<col width="34%" />
<col width="23%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">XT scancode</th>
<th class="head">X11 keysym</th>
<th class="head">RFB keycode</th>
<th class="head">down-flag</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0x1e</td>
<td>XK_A (0x41)</td>
<td>0x1e</td>
<td>1</td>
</tr>
<tr><td>0x9e</td>
<td>XK_A (0x41)</td>
<td>0x1e</td>
<td>0</td>
</tr>
<tr><td>0xe0 0x4d</td>
<td>XK_Right (0xff53)</td>
<td>0xcd</td>
<td>1</td>
</tr>
<tr><td>0xe0 0xcd</td>
<td>XK_Right (0xff53)</td>
<td>0xcd</td>
<td>0</td>
</tr>
</tbody>
</table>
<h5><a class="toc-backref" href="#id56">7.4.12.2&nbsp;&nbsp;&nbsp;QEMU Audio Client Message</a></h5>
<p>This submessage allows the client to control how the audio data
stream is received. There are three operations that can be invoked
with this submessage, the payload varies according to which
operation is requested.</p>
<p>The first operation enables audio capture from the server:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>0</td>
<td><em>operation</em></td>
</tr>
</tbody>
</table>
<p>After invoking this operation, the client will receive a
<a class="reference internal" href="#qemu-audio-server-message">QEMU Audio Server Message</a> when an audio stream begins.</p>
<p>The second operation is the inverse, to disable audio capture
on the server:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>1</td>
<td><em>operation</em></td>
</tr>
</tbody>
</table>
<p>Due to inherant race conditions in the protocol, after invoking this
operation, the client may still receive further
<a class="reference internal" href="#qemu-audio-server-message">QEMU Audio Server Message</a> messages for a short time.</p>
<p>The third and final operation is to set the audio sample format.
This should be set before audio capture is enabled on the server,
otherwise the client will not be able to reliably interpret the
receiving audio buffers:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>2</td>
<td><em>operation</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>sample-format</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>nchannels</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td><em>frequency</em></td>
</tr>
</tbody>
</table>
<p>The <em>sample-format</em> field must take one of the following values,
and this describes the number of bytes that each sample will
consume:</p>
<table class="docutils">
<colgroup>
<col width="23%" />
<col width="50%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Value</th>
<th class="head">No. of bytes</th>
<th class="head">Type</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>1</td>
<td><tt class="docutils literal">U8</tt></td>
</tr>
<tr><td>1</td>
<td>1</td>
<td><tt class="docutils literal">S8</tt></td>
</tr>
<tr><td>2</td>
<td>2</td>
<td><tt class="docutils literal">U16</tt></td>
</tr>
<tr><td>3</td>
<td>2</td>
<td><tt class="docutils literal">S16</tt></td>
</tr>
<tr><td>4</td>
<td>4</td>
<td><tt class="docutils literal">U32</tt></td>
</tr>
<tr><td>5</td>
<td>4</td>
<td><tt class="docutils literal">S32</tt></td>
</tr>
</tbody>
</table>
<p>The <em>nchannels</em> field must be either <tt class="docutils literal">1</tt> (mono) or <tt class="docutils literal">2</tt> (stereo).</p>
<h3><a class="toc-backref" href="#id57">7.5&nbsp;&nbsp;&nbsp;Server to Client Messages</a></h3>
<p>The server to client message types that all clients must support are:</p>
<table class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Number</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td><a class="reference internal" href="#framebufferupdate">FramebufferUpdate</a></td>
</tr>
<tr><td>1</td>
<td><a class="reference internal" href="#setcolourmapentries">SetColourMapEntries</a></td>
</tr>
<tr><td>2</td>
<td><a class="reference internal" href="#bell">Bell</a></td>
</tr>
<tr><td>3</td>
<td><a class="reference internal" href="#servercuttext">ServerCutText</a></td>
</tr>
</tbody>
</table>
<p>Optional message types are:</p>
<table class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Number</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td>ResizeFrameBuffer</td>
</tr>
<tr><td>5</td>
<td>KeyFrameUpdate</td>
</tr>
<tr><td>6</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr><td>7</td>
<td>FileTransfer</td>
</tr>
<tr><td>8-10</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr><td>11</td>
<td>TextChat</td>
</tr>
<tr><td>12</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr><td>13</td>
<td>KeepAlive</td>
</tr>
<tr><td>14</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr><td>15</td>
<td>ResizeFrameBuffer</td>
</tr>
<tr><td>127</td>
<td>VMWare</td>
</tr>
<tr><td>128</td>
<td>Car Connectivity</td>
</tr>
<tr><td>150</td>
<td><a class="reference internal" href="#endofcontinuousupdates">EndOfContinuousUpdates</a></td>
</tr>
<tr><td>173</td>
<td>ServerState</td>
</tr>
<tr><td>248</td>
<td><a class="reference internal" href="#serverfence">ServerFence</a></td>
</tr>
<tr><td>249</td>
<td>OLIVE Call Control</td>
</tr>
<tr><td>250</td>
<td><a class="reference internal" href="#xvp-server-message">xvp Server Message</a></td>
</tr>
<tr><td>252</td>
<td>tight</td>
</tr>
<tr><td>253</td>
<td><a class="reference internal" href="#gii-server-message">gii Server Message</a></td>
</tr>
<tr><td>254</td>
<td>VMWare</td>
</tr>
<tr><td>255</td>
<td><a class="reference internal" href="#qemu-server-message">QEMU Server Message</a></td>
</tr>
</tbody>
</table>
<p>The official, up-to-date list is maintained by IANA <a class="footnote-reference" href="#reg" id="id5">[1]</a>.</p>
<p>Note that before sending a message with an optional message type a
server must have determined that the client supports the relevant
extension by receiving some extension-specific confirmation from the
client; usually a request for a given pseudo-encoding.</p>
<h4><a class="toc-backref" href="#id58">7.5.1&nbsp;&nbsp;&nbsp;FramebufferUpdate</a></h4>
<p>A framebuffer update consists of a sequence of rectangles of pixel data
which the client should put into its framebuffer. It is sent in
response to a <em>FramebufferUpdateRequest</em> from the client. Note that
there may be an indefinite period between the
<em>FramebufferUpdateRequest</em> and the <em>FramebufferUpdate</em>.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>0</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>number-of-rectangles</em></td>
</tr>
</tbody>
</table>
<p>This is followed by <em>number-of-rectangles</em> rectangles of pixel data.
Each rectangle consists of:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>x-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>y-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>width</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>height</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">S32</tt></td>
<td><em>encoding-type</em></td>
</tr>
</tbody>
</table>
<p>followed by the pixel data in the specified encoding. See <a class="reference internal" href="#encodings">Encodings</a>
for the format of the data for each encoding and <a class="reference internal" href="#pseudo-encodings">Pseudo-encodings</a>
for the meaning of pseudo-encodings.</p>
<p>Note that a framebuffer update marks a transition from one valid
framebuffer state to another. That means that a single update handles
all received <em>FramebufferUpdateRequest</em> up to the point where the
update is sent out.</p>
<p>However, because there is no strong connection between a
<em>FramebufferUpdateRequest</em> and a subsequent <em>FramebufferUpdate</em>, a
client that has more than one <em>FramebufferUpdateRequest</em> pending at any
given time cannot be sure that it has received all framebuffer updates.</p>
<p>See the <a class="reference internal" href="#lastrect-pseudo-encoding">LastRect Pseudo-encoding</a> for an extension to this message.</p>
<h4><a class="toc-backref" href="#id59">7.5.2&nbsp;&nbsp;&nbsp;SetColourMapEntries</a></h4>
<p>When the pixel format uses a &quot;colour map&quot;, this message tells the
client that the specified pixel values should be mapped to the given
RGB intensities.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>first-colour</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>&nbsp;</td>
<td><em>number-of-colours</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-colours</em> repetitions of the following:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>red</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>green</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>blue</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id60">7.5.3&nbsp;&nbsp;&nbsp;Bell</a></h4>
<p>Ring a bell on the client if it has one.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>2</td>
<td><em>message-type</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id61">7.5.4&nbsp;&nbsp;&nbsp;ServerCutText</a></h4>
<p>The server has new ISO 8859-1 (Latin-1) text in its cut buffer. Ends of
lines are represented by the linefeed / newline character (value 10)
alone. No carriage-return (value 13) is needed. There is currently no
way to transfer text outside the Latin-1 character set.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>3</td>
<td><em>message-type</em></td>
</tr>
<tr><td>3</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td><em>length</em></td>
</tr>
<tr><td><em>length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>&nbsp;</td>
<td><em>text</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id62">7.5.5&nbsp;&nbsp;&nbsp;EndOfContinuousUpdates</a></h4>
<p>This message is sent whenever the server sees a
<a class="reference internal" href="#enablecontinuousupdates">EnableContinuousUpdates</a> message with <em>enable</em> set to a non-zero
value. It indicates that the server has stopped sending continuous
updates and is now only reacting to <a class="reference internal" href="#framebufferupdaterequest">FramebufferUpdateRequest</a>
messages.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>150</td>
<td><em>message-type</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id63">7.5.6&nbsp;&nbsp;&nbsp;ServerFence</a></h4>
<p>A server supporting the <em>Fence</em> extension sends this to request a
synchronisation of the data stream.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>248</td>
<td><em>message-type</em></td>
</tr>
<tr><td>3</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td><em>flags</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>length</em></td>
</tr>
<tr><td><em>length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>&nbsp;</td>
<td><em>payload</em></td>
</tr>
</tbody>
</table>
<p>The format and semantics is identical to <a class="reference internal" href="#clientfence">ClientFence</a>, but with the
roles of the client and server reversed.</p>
<h4><a class="toc-backref" href="#id64">7.5.7&nbsp;&nbsp;&nbsp;xvp Server Message</a></h4>
<p>This has the following format:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>250</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1</td>
<td><em>xvp-extension-version</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>xvp-message-code</em></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>xvp-message-code</em> are: 0 - XVP_FAIL and 1 -
XVP_INIT.</p>
<p>A server which supports the <em>xvp</em> extension declares this by sending a
message with an XVP_INIT <em>xvp-message-code</em> when it receives a request
from the client to use the <a class="reference internal" href="#xvp-pseudo-encoding">xvp Pseudo-encoding</a>.  The server must
specify in this message the highest <em>xvp-extension-version</em> it supports:
the client may assume that the server supports all versions from 1 up to
this value.  The client is then free to use any supported version.
Currently, only version 1 is defined.</p>
<p>A server which subsequently receives an <a class="reference internal" href="#xvp-client-message">xvp Client Message</a> requesting
an operation which it is unable to perform, informs the client of this
by sending a message with an XVP_FAIL <em>xvp-message-code</em>, and the same
<em>xvp-extension-version</em> as included in the client's operation request.</p>
<h4><a class="toc-backref" href="#id65">7.5.8&nbsp;&nbsp;&nbsp;gii Server Message</a></h4>
<p>This message is an extension and may only be sent if the server has
previously received a <a class="reference internal" href="#setencodings">SetEncodings</a> message confirming that the
client supports the General Input Interface extension via the <a class="reference internal" href="#gii-pseudo-encoding">gii
Pseudo-encoding</a>.</p>
<h5><a class="toc-backref" href="#id66">7.5.8.1&nbsp;&nbsp;&nbsp;Version</a></h5>
<p>The server response from a server with <em>gii</em> capabilities to a client
declaring <em>gii</em> capabilities is a <em>gii</em> version message:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">SUB_TYPE</tt></td>
<td>1 or 129</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>4</td>
<td><em>length</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>1</td>
<td><em>maximum-version</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>1</td>
<td><em>minimum-version</em></td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit indicating
big endian if set, and little endian if cleared. The rest of the bits
are the actual message sub type.</p>
<h5><a class="toc-backref" href="#id67">7.5.8.2&nbsp;&nbsp;&nbsp;Device Creation Response</a></h5>
<p>The server response to a <em>gii</em> Device Creation request from the client
is the following response:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">SUB_TYPE</tt></td>
<td>2 or 130</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">EU16</tt></td>
<td>4</td>
<td><em>length</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">EU32</tt></td>
<td>&nbsp;</td>
<td><em>device-origin</em></td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit indicating
big endian if set, and little endian if cleared. The rest of the bits
are the actual message sub type.</p>
<p><em>device-origin</em> is used as a handle to the device in subsequent
communications. A <em>device-origin</em> of zero indicates device creation
failure.</p>
<h4><a class="toc-backref" href="#id68">7.5.9&nbsp;&nbsp;&nbsp;QEMU Server Message</a></h4>
<p>This message may only be sent if the client has previously received
a <em>FrameBufferUpdate</em> that confirms support for the intended
<em>submessage-type</em>. Every <tt class="docutils literal">QEMU Server Message</tt> begins with
a standard header</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>submessage-type</em></td>
</tr>
</tbody>
</table>
<p>This header is then followed by arbitrary data whose format is
determined by the <em>submessage-type</em>. Possible values for
<em>submessage-type</em> and their associated psuedo encodings are</p>
<table class="docutils">
<colgroup>
<col width="31%" />
<col width="31%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Submessage Type</th>
<th class="head">Psuedo Encoding</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td>-259</td>
<td>Audio</td>
</tr>
</tbody>
</table>
<p>Submessage type 0 is unused, since the
<a class="reference internal" href="#qemu-extended-key-event-psuedo-encoding">QEMU Extended Key Event Psuedo-encoding</a> does not require any
server messages.</p>
<h5><a class="toc-backref" href="#id69">7.5.9.1&nbsp;&nbsp;&nbsp;QEMU Audio Server Message</a></h5>
<p>This submessage allows the server to send an audio data stream
to the client. There are three operations that can be invoked
with this submessage, the payload varies according to which
operation is requested.</p>
<p>The first operation informs the client that an audio stream is
about to start</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>1</td>
<td><em>operation</em></td>
</tr>
</tbody>
</table>
<p>The second operation informs the client that an audio stream has
now finished:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>0</td>
<td><em>operation</em></td>
</tr>
</tbody>
</table>
<p>The third and final operation is to provide audio data.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="15%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td>2</td>
<td><em>operation</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td>&nbsp;</td>
<td><em>data-length</em></td>
</tr>
<tr><td><em>data-length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>&nbsp;</td>
<td><em>data</em></td>
</tr>
</tbody>
</table>
<p>The <em>data-length</em> will be a multiple of (<em>sample-format</em> * <em>nchannels</em>)
as requested by the client in an earlier <a class="reference internal" href="#qemu-audio-client-message">QEMU Audio Client Message</a>.</p>
<h3><a class="toc-backref" href="#id70">7.6&nbsp;&nbsp;&nbsp;Encodings</a></h3>
<p>The encodings defined in this document are:</p>
<table class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Number</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td><a class="reference internal" href="#raw-encoding">Raw Encoding</a></td>
</tr>
<tr><td>1</td>
<td><a class="reference internal" href="#copyrect-encoding">CopyRect Encoding</a></td>
</tr>
<tr><td>2</td>
<td><a class="reference internal" href="#rre-encoding">RRE Encoding</a></td>
</tr>
<tr><td>4</td>
<td><a class="reference internal" href="#corre-encoding">CoRRE Encoding</a></td>
</tr>
<tr><td>5</td>
<td><a class="reference internal" href="#hextile-encoding">Hextile Encoding</a></td>
</tr>
<tr><td>6</td>
<td><a class="reference internal" href="#zlib-encoding">zlib Encoding</a></td>
</tr>
<tr><td>7</td>
<td><a class="reference internal" href="#tight-encoding">Tight Encoding</a></td>
</tr>
<tr><td>8</td>
<td><a class="reference internal" href="#zlibhex-encoding">zlibhex Encoding</a></td>
</tr>
<tr><td>16</td>
<td><a class="reference internal" href="#zrle-encoding">ZRLE Encoding</a></td>
</tr>
<tr><td>-23 to -32</td>
<td><a class="reference internal" href="#jpeg-quality-level-pseudo-encoding">JPEG Quality Level Pseudo-encoding</a></td>
</tr>
<tr><td>-223</td>
<td><a class="reference internal" href="#desktopsize-pseudo-encoding">DesktopSize Pseudo-encoding</a></td>
</tr>
<tr><td>-224</td>
<td><a class="reference internal" href="#lastrect-pseudo-encoding">LastRect Pseudo-encoding</a></td>
</tr>
<tr><td>-239</td>
<td><a class="reference internal" href="#cursor-pseudo-encoding">Cursor Pseudo-encoding</a></td>
</tr>
<tr><td>-240</td>
<td><a class="reference internal" href="#x-cursor-pseudo-encoding">X Cursor Pseudo-encoding</a></td>
</tr>
<tr><td>-247 to -256</td>
<td><a class="reference internal" href="#compression-level-pseudo-encoding">Compression Level Pseudo-encoding</a></td>
</tr>
<tr><td>-257</td>
<td><a class="reference internal" href="#qemu-pointer-motion-change-psuedo-encoding">QEMU Pointer Motion Change Psuedo-encoding</a></td>
</tr>
<tr><td>-258</td>
<td><a class="reference internal" href="#qemu-extended-key-event-psuedo-encoding">QEMU Extended Key Event Psuedo-encoding</a></td>
</tr>
<tr><td>-259</td>
<td><a class="reference internal" href="#qemu-audio-psuedo-encoding">QEMU Audio Psuedo-encoding</a></td>
</tr>
<tr><td>-305</td>
<td><a class="reference internal" href="#gii-pseudo-encoding">gii Pseudo-encoding</a></td>
</tr>
<tr><td>-307</td>
<td><a class="reference internal" href="#desktopname-pseudo-encoding">DesktopName Pseudo-encoding</a></td>
</tr>
<tr><td>-308</td>
<td><a class="reference internal" href="#extendeddesktopsize-pseudo-encoding">ExtendedDesktopSize Pseudo-encoding</a></td>
</tr>
<tr><td>-309</td>
<td><a class="reference internal" href="#xvp-pseudo-encoding">xvp Pseudo-encoding</a></td>
</tr>
<tr><td>-312</td>
<td><a class="reference internal" href="#fence-pseudo-encoding">Fence Pseudo-encoding</a></td>
</tr>
<tr><td>-313</td>
<td><a class="reference internal" href="#continuousupdates-pseudo-encoding">ContinuousUpdates Pseudo-encoding</a></td>
</tr>
<tr><td>-412 to -512</td>
<td><a class="reference internal" href="#jpeg-fine-grained-quality-level-pseudo-encoding">JPEG Fine-Grained Quality Level Pseudo-encoding</a></td>
</tr>
<tr><td>-763 to -768</td>
<td><a class="reference internal" href="#jpeg-subsampling-level-pseudo-encoding">JPEG Subsampling Level Pseudo-encoding</a></td>
</tr>
</tbody>
</table>
<p>Other registered encodings are:</p>
<table class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Number</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>9</td>
<td>Ultra</td>
</tr>
<tr><td>10</td>
<td>Ultra2</td>
</tr>
<tr><td>15</td>
<td>TRLE</td>
</tr>
<tr><td>17</td>
<td>Hitachi ZYWRLE</td>
</tr>
<tr><td>20</td>
<td>H.264</td>
</tr>
<tr><td>21</td>
<td>JPEG</td>
</tr>
<tr><td>22</td>
<td>JRLE</td>
</tr>
<tr><td>1000 to 1002</td>
<td>Apple Inc.</td>
</tr>
<tr><td>1011</td>
<td>Apple Inc.</td>
</tr>
<tr><td>1024 to 1099</td>
<td>RealVNC</td>
</tr>
<tr><td>1100 to 1105</td>
<td>Apple Inc.</td>
</tr>
<tr><td>-1 to -22</td>
<td>Tight options</td>
</tr>
<tr><td>-33 to -222</td>
<td>Tight options</td>
</tr>
<tr><td>-225</td>
<td>PointerPos</td>
</tr>
<tr><td>-226 to -238</td>
<td>Tight options</td>
</tr>
<tr><td>-241 to -246</td>
<td>Tight options</td>
</tr>
<tr><td>-260 to -272</td>
<td>QEMU</td>
</tr>
<tr><td>-273 to -304</td>
<td>VMWare</td>
</tr>
<tr><td>-306</td>
<td>popa</td>
</tr>
<tr><td>-310</td>
<td>OLIVE Call Control</td>
</tr>
<tr><td>-311</td>
<td>ClientRedirect</td>
</tr>
<tr><td>-523 to -528</td>
<td>Car Connectivity</td>
</tr>
<tr><td>0x48323634</td>
<td>VA H.264</td>
</tr>
<tr><td>0x574d5600 to 0x574d56ff</td>
<td>VMWare</td>
</tr>
<tr><td>0xc0a1e5ce</td>
<td>ExtendedClipboard</td>
</tr>
<tr><td>0xc0a1e5cf</td>
<td>PluginStreaming</td>
</tr>
<tr><td>0xffff0000</td>
<td>Cache</td>
</tr>
<tr><td>0xffff0001</td>
<td>CacheEnable</td>
</tr>
<tr><td>0xffff0002</td>
<td>XOR zlib</td>
</tr>
<tr><td>0xffff0003</td>
<td>XORMonoRect zlib</td>
</tr>
<tr><td>0xffff0004</td>
<td>XORMultiColor zlib</td>
</tr>
<tr><td>0xffff0005</td>
<td>SolidColor</td>
</tr>
<tr><td>0xffff0006</td>
<td>XOREnable</td>
</tr>
<tr><td>0xffff0007</td>
<td>CacheZip</td>
</tr>
<tr><td>0xffff0008</td>
<td>SolMonoZip</td>
</tr>
<tr><td>0xffff0009</td>
<td>UltraZip</td>
</tr>
<tr><td>0xffff8000</td>
<td>ServerState</td>
</tr>
<tr><td>0xffff8001</td>
<td>EnableKeepAlive</td>
</tr>
<tr><td>0xffff8002</td>
<td>FTProtocolVersion</td>
</tr>
<tr><td>0xffff8003</td>
<td>Session</td>
</tr>
</tbody>
</table>
<p>The official, up-to-date list is maintained by IANA <a class="footnote-reference" href="#reg" id="id7">[1]</a>.</p>
<h4><a class="toc-backref" href="#id71">7.6.1&nbsp;&nbsp;&nbsp;Raw Encoding</a></h4>
<p>The simplest encoding type is raw pixel data. In this case the data
consists of <em>width</em> * <em>height</em> pixel values (where <em>width</em> and <em>height</em>
are the width and height of the rectangle). The values simply represent
each pixel in left-to-right scanline order. All RFB clients must be
able to cope with pixel data in this raw encoding, and RFB servers
should only produce raw encoding unless the client specifically asks
for some other encoding type.</p>
<table class="docutils">
<colgroup>
<col width="57%" />
<col width="28%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>width</em> * <em>height</em> * <em>bytesPerPixel</em></td>
<td><tt class="docutils literal">PIXEL</tt> array</td>
<td><em>pixels</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id72">7.6.2&nbsp;&nbsp;&nbsp;CopyRect Encoding</a></h4>
<p>The <em>CopyRect</em> (copy rectangle) encoding is a very simple and efficient
encoding which can be used when the client already has the same pixel
data elsewhere in its framebuffer. The encoding on the wire simply
consists of an X,Y coordinate. This gives a position in the framebuffer
from which the client can copy the rectangle of pixel data. This can be
used in a variety of situations, the most obvious of which are when the
user moves a window across the screen, and when the contents of a
window are scrolled. A less obvious use is for optimising drawing of
text or other repeating patterns. An intelligent server may be able to
send a pattern explicitly only once, and knowing the previous position
of the pattern in the framebuffer, send subsequent occurrences of the
same pattern using the <em>CopyRect</em> encoding.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>src-x-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>src-y-position</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id73">7.6.3&nbsp;&nbsp;&nbsp;RRE Encoding</a></h4>
<p>RRE stands for <em>rise-and-run-length encoding</em> and as its name implies,
it is essentially a two-dimensional analogue of run-length encoding.
RRE-encoded rectangles arrive at the client in a form which can be
rendered immediately and efficiently by the simplest of graphics
engines. RRE is not appropriate for complex desktops, but can be useful
in some situations.</p>
<p>The basic idea behind RRE is the partitioning of a rectangle of pixel
data into rectangular subregions (subrectangles) each of which consists
of pixels of a single value and the union of which comprises the
original rectangular region. The near-optimal partition of a given
rectangle into such subrectangles is relatively easy to compute.</p>
<p>The encoding consists of a background pixel value, <em>Vb</em> (typically the
most prevalent pixel value in the rectangle) and a count <em>N</em>, followed
by a list of <em>N</em> subrectangles, each of which consists of a tuple
&lt;<em>v</em>, <em>x</em>, <em>y</em>, <em>w</em>, <em>h</em>&gt; where <em>v</em> (!= <em>Vb</em>) is the pixel value, (<em>x</em>,
<em>y</em>) are the coordinates of the subrectangle relative to the top-left
corner of the rectangle, and (<em>w</em>, <em>h</em>) are the width and height of the
subrectangle. The client can render the original rectangle by drawing a
filled rectangle of the background pixel value and then drawing a
filled rectangle corresponding to each subrectangle.</p>
<p>On the wire, the data begins with the header:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>number-of-subrectangles</em></td>
</tr>
<tr><td><em>bytesPerPixel</em></td>
<td><tt class="docutils literal">PIXEL</tt></td>
<td><em>background-pixel-value</em></td>
</tr>
</tbody>
</table>
<p>This is followed by <em>number-of-subrectangles</em> instances of the
following structure:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>bytesPerPixel</em></td>
<td><tt class="docutils literal">PIXEL</tt></td>
<td><em>subrect-pixel-value</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>x-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>y-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>width</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>height</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id74">7.6.4&nbsp;&nbsp;&nbsp;CoRRE Encoding</a></h4>
<p>CoRRE stands for <em>compressed rise-and-run-length encoding</em> and as its
name implies, it is a variant of the above <a class="reference internal" href="#rre-encoding">RRE Encoding</a> and as such
essentially a two-dimensional analogue of run-length encoding.</p>
<p>The only difference between CoRRE and RRE is that the position, width
and height of the subrectangles are limited to a maximum of 255 pixels.
Because of this, the server needs to produce several rectangles in
order to cover a larger area. The <a class="reference internal" href="#hextile-encoding">Hextile Encoding</a> is probably a
better choice in the majority of cases.</p>
<p>On the wire, the data begins with the header:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>number-of-subrectangles</em></td>
</tr>
<tr><td><em>bytesPerPixel</em></td>
<td><tt class="docutils literal">PIXEL</tt></td>
<td><em>background-pixel-value</em></td>
</tr>
</tbody>
</table>
<p>This is followed by <em>number-of-subrectangles</em> instances of the
following structure:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>bytesPerPixel</em></td>
<td><tt class="docutils literal">PIXEL</tt></td>
<td><em>subrect-pixel-value</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>x-position</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>y-position</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>width</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>height</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id75">7.6.5&nbsp;&nbsp;&nbsp;Hextile Encoding</a></h4>
<p>Hextile is a variation on the RRE idea. Rectangles are split up into
16x16 tiles, allowing the dimensions of the subrectangles to be
specified in 4 bits each, 16 bits in total. The rectangle is split into
tiles starting at the top left going in left-to-right, top-to-bottom
order. The encoded contents of the tiles simply follow one another in
the predetermined order. If the width of the whole rectangle is not an
exact multiple of 16 then the width of the last tile in each row will
be correspondingly smaller. Similarly if the height of the whole
rectangle is not an exact multiple of 16 then the height of each tile
in the final row will also be smaller.</p>
<p>Each tile is either encoded as raw pixel data, or as a variation on
RRE. Each tile has a background pixel value, as before. The background
pixel value does not need to be explicitly specified for a given tile
if it is the same as the background of the previous tile. However the
background pixel value may not be carried over if the previous tile was
raw. If all of the subrectangles of a tile have the same pixel value,
this can be specified once as a foreground pixel value for the whole
tile. As with the background, the foreground pixel value can be left
unspecified, meaning it is carried over from the previous tile. The
foreground pixel value may not be carried over if the previous tile was
raw or had the SubrectsColored bit set. It may, however, be carried
over from a previous tile with the AnySubrects bit clear, as long as
that tile itself carried over a valid foreground from its previous
tile.</p>
<p>So the data consists of each tile encoded in order. Each tile begins
with a subencoding type byte, which is a mask made up of a number of
bits:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="16%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>subencoding-mask</em>:</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>1</td>
<td><strong>Raw</strong></td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>2</td>
<td><strong>BackgroundSpecified</strong></td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>4</td>
<td><strong>ForegroundSpecified</strong></td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>8</td>
<td><strong>AnySubrects</strong></td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>16</td>
<td><strong>SubrectsColoured</strong></td>
</tr>
</tbody>
</table>
<p>If the <strong>Raw</strong> bit is set then the other bits are irrelevant; <em>width</em> *
<em>height</em> pixel values follow (where <em>width</em> and <em>height</em> are the width
and height of the tile). Otherwise the other bits in the mask are as
follows:</p>
<dl class="docutils">
<dt><strong>BackgroundSpecified</strong></dt>
<dd><p class="first">If set, a pixel value follows which specifies the background colour
for this tile:</p>
<table class="docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>bytesPerPixel</em></td>
<td><tt class="docutils literal">PIXEL</tt></td>
<td><em>background-pixel-value</em></td>
</tr>
</tbody>
</table>
<p class="last">The first non-raw tile in a rectangle must have this bit set. If
this bit isn't set then the background is the same as the last
tile.</p>
</dd>
<dt><strong>ForegroundSpecified</strong></dt>
<dd><p class="first">If set, a pixel value follows which specifies the foreground colour
to be used for all subrectangles in this tile:</p>
<table class="docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>bytesPerPixel</em></td>
<td><tt class="docutils literal">PIXEL</tt></td>
<td><em>foreground-pixel-value</em></td>
</tr>
</tbody>
</table>
<p class="last">If this bit is set then the <strong>SubrectsColoured</strong> bit must be zero.</p>
</dd>
<dt><strong>AnySubrects</strong></dt>
<dd><p class="first">If set, a single byte follows giving the number of subrectangles
following:</p>
<table class="docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>number-of-subrectangles</em></td>
</tr>
</tbody>
</table>
<p class="last">If not set, there are no subrectangles (i.e. the whole tile is just
solid background colour).</p>
</dd>
<dt><strong>SubrectsColoured</strong></dt>
<dd><p class="first">If set then each subrectangle is preceded by a pixel value giving
the colour of that subrectangle, so a subrectangle is:</p>
<table class="docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>bytesPerPixel</em></td>
<td><tt class="docutils literal">PIXEL</tt></td>
<td><em>subrect-pixel-value</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>x-and-y-position</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>width-and-height</em></td>
</tr>
</tbody>
</table>
<p>If not set, all subrectangles are the same colour, the foreground
colour; if the <strong>ForegroundSpecified</strong> bit wasn't set then the
foreground is the same as the last tile. A subrectangle is:</p>
<table class="last docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>x-and-y-position</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>width-and-height</em></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>The position and size of each subrectangle is specified in two bytes,
<em>x-and-y-position</em> and <em>width-and-height</em>. The most-significant four
bits of <em>x-and-y-position</em> specify the X position, the
least-significant specify the Y position. The most-significant four
bits of <em>width-and-height</em> specify the width minus one, the
least-significant specify the height minus one.</p>
<h4><a class="toc-backref" href="#id76">7.6.6&nbsp;&nbsp;&nbsp;zlib Encoding</a></h4>
<p>The zlib encoding uses zlib <a class="footnote-reference" href="#zlib" id="id8">[3]</a> to compress rectangles encoded
according to the <a class="reference internal" href="#raw-encoding">Raw Encoding</a>. A single zlib &quot;stream&quot; object is used
for a given RFB connection, so that zlib rectangles must be encoded and
decoded strictly in order.</p>
<table class="docutils footnote" frame="void" id="zlib" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id10">2</a>, <a class="fn-backref" href="#id11">3</a>)</em> see <a class="reference external" href="http://www.gzip.org/zlib/">http://www.gzip.org/zlib/</a></td></tr>
</tbody>
</table>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>length</em></td>
</tr>
<tr><td><em>length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>zlibData</em></td>
</tr>
</tbody>
</table>
<p>The <em>zlibData</em>, when uncompressed, represents a rectangle according to
the <a class="reference internal" href="#raw-encoding">Raw Encoding</a>.</p>
<h4><a class="toc-backref" href="#id77">7.6.7&nbsp;&nbsp;&nbsp;Tight Encoding</a></h4>
<p>Tight encoding provides efficient compression for pixel data. To
reduce implementation complexity, the width of any Tight-encoded
rectangle cannot exceed 2048 pixels. If a wider rectangle is desired,
it must be split into several rectangles and each one should be encoded
separately.</p>
<p>The first byte of each Tight-encoded rectangle is a
<em>compression-control</em> byte:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>compression-control</em></td>
</tr>
</tbody>
</table>
<p>The least significant four bits of the <em>compression-control</em> byte
inform the client which zlib compression streams should be reset before
decoding the rectangle. Each bit is independent and corresponds to a
separate zlib stream that should be reset:</p>
<table class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Bit</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>Reset stream 0</td>
</tr>
<tr><td>1</td>
<td>Reset stream 1</td>
</tr>
<tr><td>2</td>
<td>Reset stream 2</td>
</tr>
<tr><td>3</td>
<td>Reset stream 3</td>
</tr>
</tbody>
</table>
<p>One of three possible compression methods are supported in the Tight
encoding. These are <strong>BasicCompression</strong>, <strong>FillCompression</strong> and
<strong>JpegCompression</strong>. If the bit 7 (the most significant bit) of the
<em>compression-control</em> byte is 0, then the compression type is
<strong>BasicCompression</strong>. In that case, bits 7-4 (the most significant four
bits) of <em>compression-control</em> should be interpreted as follows:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Bits</th>
<th class="head">Binary value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>5-4</td>
<td>00</td>
<td>Use stream 0</td>
</tr>
<tr><td>&nbsp;</td>
<td>01</td>
<td>Use stream 1</td>
</tr>
<tr><td>&nbsp;</td>
<td>10</td>
<td>Use stream 2</td>
</tr>
<tr><td>&nbsp;</td>
<td>11</td>
<td>Use stream 3</td>
</tr>
<tr><td>6</td>
<td>0</td>
<td>---</td>
</tr>
<tr><td>&nbsp;</td>
<td>1</td>
<td><em>read-filter-id</em></td>
</tr>
<tr><td>7</td>
<td>0</td>
<td><strong>BasicCompression</strong></td>
</tr>
</tbody>
</table>
<p>Otherwise, if the bit 7 of <em>compression-control</em> is set to 1, then the
compression method is either <strong>FillCompression</strong> or
<strong>JpegCompression</strong>, depending on other bits of the same byte:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Bits</th>
<th class="head">Binary value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>7-4</td>
<td>1000</td>
<td><strong>FillCompression</strong></td>
</tr>
<tr><td>&nbsp;</td>
<td>1001</td>
<td><strong>JpegCompression</strong></td>
</tr>
<tr><td>&nbsp;</td>
<td>any other</td>
<td>Invalid</td>
</tr>
</tbody>
</table>
<p>Note: <strong>JpegCompression</strong> may only be used when <em>bits-per-pixel</em> is
either 16 or 32 and the client has advertized a quality level using the
<a class="reference internal" href="#jpeg-quality-level-pseudo-encoding">JPEG Quality Level Pseudo-encoding</a>.</p>
<p>The Tight encoding makes use of a new type <tt class="docutils literal">TPIXEL</tt> (Tight pixel).
This is the same as a <tt class="docutils literal">PIXEL</tt> for the agreed pixel format, except
where <em>true-colour-flag</em> is non-zero, <em>bits-per-pixel</em> is 32, <em>depth</em>
is 24 and all of the bits making up the red, green and blue intensities
are exactly 8 bits wide. In this case a <tt class="docutils literal">TPIXEL</tt> is only 3 bytes
long, where the first byte is the red component, the second byte is the
green component, and the third byte is the blue component of the pixel
color value.</p>
<p>The data following the <em>compression-control</em> byte depends on the
compression method.</p>
<dl class="docutils">
<dt><strong>FillCompression</strong></dt>
<dd>If the compression type is <strong>FillCompression</strong>, then the only pixel
value follows, in <tt class="docutils literal">TPIXEL</tt> format. This value applies to all
pixels of the rectangle.</dd>
<dt><strong>JpegCompression</strong></dt>
<dd><p class="first">If the compression type is <strong>JpegCompression</strong>, the following data
stream looks like this:</p>
<table class="docutils">
<colgroup>
<col width="23%" />
<col width="25%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1-3</td>
<td>&nbsp;</td>
<td><em>length</em> in compact representation</td>
</tr>
<tr><td><em>length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>jpeg-data</em></td>
</tr>
</tbody>
</table>
<p><em>length</em> is compactly represented in one, two or three bytes,
according to the following scheme:</p>
<table class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0xxxxxxx</td>
<td>for values 0..127</td>
</tr>
<tr><td>1xxxxxxx 0yyyyyyy</td>
<td>for values 128..16383</td>
</tr>
<tr><td>1xxxxxxx 1yyyyyyy zzzzzzzz</td>
<td>for values 16384..4194303</td>
</tr>
</tbody>
</table>
<p>Here each character denotes one bit, xxxxxxx are the least
significant 7 bits of the value (bits 0-6), yyyyyyy are bits 7-13,
and zzzzzzzz are the most significant 8 bits (bits 14-21). For
example, decimal value 10000 should be represented as two bytes:
binary 10010000 01001110, or hexadecimal 90 4E.</p>
<p class="last">The <em>jpeg-data</em> is a JFIF stream.</p>
</dd>
<dt><strong>BasicCompression</strong></dt>
<dd><p class="first">If the compression type is <strong>BasicCompression</strong> and bit 6 (the
<em>read-filter-id</em> bit) of the <em>compression-control</em> byte was set to
1, then the next (second) byte specifies <em>filter-id</em> which tells
the decoder what filter type was used by the encoder to pre-process
pixel data before the compression. The <em>filter-id</em> byte can be one
of the following:</p>
<table class="docutils">
<colgroup>
<col width="23%" />
<col width="14%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>filter-id</em></td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>0</td>
<td><strong>CopyFilter</strong> (no filter)</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>1</td>
<td><strong>PaletteFilter</strong></td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>2</td>
<td><strong>GradientFilter</strong></td>
</tr>
</tbody>
</table>
<p>If bit 6 of the <em>compression-control</em> byte is set to 0 (no
<em>filter-id</em> byte), then the <strong>CopyFilter</strong> is used.</p>
<dl class="docutils">
<dt><strong>CopyFilter</strong></dt>
<dd>When the <strong>CopyFilter</strong> is active, raw pixel values in
<tt class="docutils literal">TPIXEL</tt> format will be compressed. See below for details on
the compression.</dd>
<dt><strong>PaletteFilter</strong></dt>
<dd>The <strong>PaletteFilter</strong> converts true-color pixel data to indexed
colors and a palette which can consist of 2..256 colors. If the
number of colors is 2, then each pixel is encoded in 1 bit,
otherwise 8 bits are used to encode one pixel. 1-bit encoding
is performed such way that the most significant bits correspond
to the leftmost pixels, and each row of pixels is aligned to
the byte boundary. When the <strong>PaletteFilter</strong> is used, the
palette is sent before the pixel data. The palette begins with
an unsigned byte which value is the number of colors in the
palette minus 1 (i.e. 1 means 2 colors, 255 means 256 colors in
the palette). Then follows the palette itself which consist of
pixel values in <tt class="docutils literal">TPIXEL</tt> format.</dd>
<dt><strong>GradientFilter</strong></dt>
<dd><p class="first">The <strong>GradientFilter</strong> pre-processes pixel data with a simple
algorithm which converts each color component to a difference
between a &quot;predicted&quot; intensity and the actual intensity. Such
a technique does not affect uncompressed data size, but helps
to compress photo-like images better. Pseudo-code for
converting intensities to differences follows:</p>
<pre>
P[i,j] := V[i-1,j] + V[i,j-1] - V[i-1,j-1];
if (P[i,j] &lt; 0) then P[i,j] := 0;
if (P[i,j] &gt; MAX) then P[i,j] := MAX;
D[i,j] := V[i,j] - P[i,j];
</pre>
<p>Here <tt class="docutils literal">V[i,j]</tt> is the intensity of a color component for a
pixel at coordinates <tt class="docutils literal">(i,j)</tt>. For pixels outside the current
rectangle, <tt class="docutils literal">V[i,j]</tt> is assumed to be zero (which is relevant
for <tt class="docutils literal">P[i,0]</tt> and <tt class="docutils literal">P[0,j]</tt>). MAX is the maximum intensity
value for a color component.</p>
<p class="last">Note: The <strong>GradientFilter</strong> may only be used when
<em>bits-per-pixel</em> is either 16 or 32.</p>
</dd>
</dl>
<p>After the pixel data has been filtered with one of the above three
filters, it is compressed using the zlib library. But if the data
size after applying the filter but before the compression is less
then 12, then the data is sent as is, uncompressed. Four separate
zlib streams (0..3) can be used and the decoder should read the
actual stream id from the <em>compression-control</em> byte (see
<a class="citation-reference" href="#note1" id="id9">[NOTE1]</a>).</p>
<p>If the compression is not used, then the pixel data is sent as is,
otherwise the data stream looks like this:</p>
<table class="docutils">
<colgroup>
<col width="23%" />
<col width="25%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1-3</td>
<td>&nbsp;</td>
<td><em>length</em> in compact representation</td>
</tr>
<tr><td><em>length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>zlibData</em></td>
</tr>
</tbody>
</table>
<p class="last"><em>length</em> is compactly represented in one, two or three bytes, just
like in the <strong>JpegCompression</strong> method (see above).</p>
</dd>
</dl>
<table class="docutils citation" frame="void" id="note1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[NOTE1]</a></td><td>The decoder must reset the zlib streams before decoding the
rectangle, if some of the bits 0, 1, 2 and 3 in the
<em>compression-control</em> byte are set to 1. Note that the decoder must
reset the indicated zlib streams even if the compression type is
<strong>FillCompression</strong> or <strong>JpegCompression</strong>.</td></tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id78">7.6.8&nbsp;&nbsp;&nbsp;zlibhex Encoding</a></h4>
<p>The zlibhex encoding uses zlib <a class="footnote-reference" href="#zlib" id="id10">[3]</a> to optionally compress
subrectangles according to the <a class="reference internal" href="#hextile-encoding">Hextile Encoding</a>. Refer to the
hextile encoding for information on how the rectangle is divided into
subrectangles and other basic properties of subrectangles. One zlib
&quot;stream&quot; object is used for subrectangles encoded according to the
<strong>Raw</strong> subencoding and one zlib &quot;stream&quot; object is used for all other
subrectangles.</p>
<p>The hextile subencoding bitfield is extended with these bits:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="10%" />
<col width="16%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>subencoding-mask</em>:</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>32</td>
<td><strong>ZlibRaw</strong></td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>64</td>
<td><strong>Zlib</strong></td>
</tr>
</tbody>
</table>
<p>If either of the <strong>ZlibRaw</strong> or the <strong>Zlib</strong> bit is set, the
subrectangle is compressed using zlib, like this:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>length</em></td>
</tr>
<tr><td><em>length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>zlibData</em></td>
</tr>
</tbody>
</table>
<p>Like the <strong>Raw</strong> bit in hextile, the <strong>ZlibRaw</strong> bit in zlibhex cancels
all other bits and the subrectangle is encoded using the first zlib
&quot;stream&quot; object. The <em>zlibData</em>, when uncompressed, should in this case
be interpreted as the <strong>Raw</strong> data in the hextile encoding.</p>
<p>If the <strong>Zlib</strong> bit is set, the rectangle is encoded using the second
zlib &quot;stream&quot; object. The <em>zlibData</em>, when uncompressed, represents a
plain hextile rectangle according to the lower 5 bits in the
subencoding.</p>
<p>If neither the <strong>ZlibRaw</strong> nor the <strong>Zlib</strong> bit is set, the
subrectangle follows the rules described in the <a class="reference internal" href="#hextile-encoding">Hextile Encoding</a>.</p>
<h4><a class="toc-backref" href="#id79">7.6.9&nbsp;&nbsp;&nbsp;ZRLE Encoding</a></h4>
<p>ZRLE stands for Zlib <a class="footnote-reference" href="#zlib" id="id11">[3]</a> Run-Length Encoding, and combines zlib
compression, tiling, palettisation and run-length encoding. On the
wire, the rectangle begins with a 4-byte length field, and is followed
by that many bytes of zlib-compressed data. A single zlib &quot;stream&quot;
object is used for a given RFB protocol connection, so that ZRLE
rectangles must be encoded and decoded strictly in order.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>length</em></td>
</tr>
<tr><td><em>length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>zlibData</em></td>
</tr>
</tbody>
</table>
<p>The <em>zlibData</em> when uncompressed represents tiles of 64x64 pixels in
left-to-right, top-to-bottom order, similar to hextile. If the width of
the rectangle is not an exact multiple of 64 then the width of the last
tile in each row is smaller, and if the height of the rectangle is not
an exact multiple of 64 then the height of each tile in the final row
is smaller.</p>
<p>ZRLE makes use of a new type <tt class="docutils literal">CPIXEL</tt> (compressed pixel). This is the
same as a <tt class="docutils literal">PIXEL</tt> for the agreed pixel format, except where
<em>true-colour-flag</em> is non-zero, <em>bits-per-pixel</em> is 32, <em>depth</em> is 24
or less and all of the bits making up the red, green and blue
intensities fit in either the least significant 3 bytes or the most
significant 3 bytes. In this case a <tt class="docutils literal">CPIXEL</tt> is only 3 bytes long,
and contains the least significant or the most significant 3 bytes as
appropriate. <em>bytesPerCPixel</em> is the number of bytes in a <tt class="docutils literal">CPIXEL</tt>.</p>
<p>Note that for the corner case where <em>bits-per-pixel</em> is 32 and <em>depth</em>
is 16 or less (this is a corner case, since the client is <strong>much</strong>
better off using 16 or even 8 <em>bits-per-pixels</em>) a <tt class="docutils literal">CPIXEL</tt> is still
3 bytes long. By convention, the three least significant bytes are used
when both the three least and the three most significant bytes would
cover the used bits.</p>
<p>Each tile begins with a <em>subencoding</em> type byte. The top bit of this
byte is set if the tile has been run-length encoded, clear otherwise.
The bottom seven bits indicate the size of the palette used: zero means
no palette, one means that the tile is of a single colour, 2 to 127
indicate a palette of that size. The possible values of <em>subencoding</em>
are:</p>
<dl class="docutils">
<dt>0</dt>
<dd><p class="first">Raw pixel data. <em>width</em> * <em>height</em> pixel values follow (where width
and height are the width and height of the tile):</p>
<table class="last docutils">
<colgroup>
<col width="58%" />
<col width="25%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>width</em> * <em>height</em> * <em>bytesPerCPixel</em></td>
<td><tt class="docutils literal">CPIXEL</tt> array</td>
<td><em>pixels</em></td>
</tr>
</tbody>
</table>
</dd>
<dt>1</dt>
<dd><p class="first">A solid tile consisting of a single colour. The pixel value
follows:</p>
<table class="last docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>bytesPerCPixel</em></td>
<td><tt class="docutils literal">CPIXEL</tt></td>
<td><em>pixelValue</em></td>
</tr>
</tbody>
</table>
</dd>
<dt>2 to 16</dt>
<dd><p class="first">Packed palette types. Followed by the palette, consisting of
<em>paletteSize</em> (=*subencoding*) pixel values. Then the packed pixels
follow, each pixel represented as a bit field yielding an index
into the palette (0 meaning the first palette entry). For
<em>paletteSize</em> 2, a 1-bit field is used, for <em>paletteSize</em> 3 or 4 a
2-bit field is used and for <em>paletteSize</em> from 5 to 16 a 4-bit
field is used. The bit fields are packed into bytes, the most
significant bits representing the leftmost pixel (i.e. big endian).
For tiles not a multiple of 8, 4 or 2 pixels wide (as appropriate),
padding bits are used to align each row to an exact number of bytes.</p>
<table class="docutils">
<colgroup>
<col width="51%" />
<col width="28%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>paletteSize</em> * <em>bytesPerCPixel</em></td>
<td><tt class="docutils literal">CPIXEL</tt> array</td>
<td><em>palette</em></td>
</tr>
<tr><td><em>m</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>packedPixels</em></td>
</tr>
</tbody>
</table>
<p class="last">where <em>m</em> is the number of bytes representing the packed pixels.
For <em>paletteSize</em> of 2 this is floor((<em>width</em> + 7) / 8) * <em>height</em>,
for <em>paletteSize</em> of 3 or 4 this is
floor((<em>width</em> + 3) / 4) * <em>height</em>, for <em>paletteSize</em> of 5 to 16
this is floor((<em>width</em> + 1) / 2) * <em>height</em>.</p>
</dd>
<dt>17 to 127</dt>
<dd>Unused (no advantage over palette RLE).</dd>
<dt>128</dt>
<dd><p class="first">Plain RLE. Consists of a number of runs, repeated until the tile is
done. Runs may continue from the end of one row to the beginning of
the next. Each run is a represented by a single pixel value
followed by the length of the run. The length is represented as one
or more bytes. The length is calculated as one more than the sum of
all the bytes representing the length. Any byte value other than
255 indicates the final byte. So for example length 1 is
represented as [0], 255 as [254], 256 as [255,0], 257 as [255,1],
510 as [255,254], 511 as [255,255,0] and so on.</p>
<table class="docutils">
<colgroup>
<col width="30%" />
<col width="23%" />
<col width="11%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>bytesPerCPixel</em></td>
<td><tt class="docutils literal">CPIXEL</tt></td>
<td>&nbsp;</td>
<td><em>pixelValue</em></td>
</tr>
<tr><td><em>r</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>255</td>
<td>&nbsp;</td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td>(<em>runLength</em> - 1) % 255</td>
</tr>
</tbody>
</table>
<p class="last">Where <em>r</em> is floor((<em>runLength</em> - 1) / 255).</p>
</dd>
<dt>129</dt>
<dd>Unused.</dd>
<dt>130 to 255</dt>
<dd><p class="first">Palette RLE. Followed by the palette, consisting of
<em>paletteSize</em> = (<em>subencoding</em> - 128) pixel values:</p>
<table class="docutils">
<colgroup>
<col width="51%" />
<col width="28%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>paletteSize</em> * <em>bytesPerCPixel</em></td>
<td><tt class="docutils literal">CPIXEL</tt> array</td>
<td><em>palette</em></td>
</tr>
</tbody>
</table>
<p>Then as with plain RLE, consists of a number of runs, repeated
until the tile is done. A run of length one is represented simply
by a palette index:</p>
<table class="docutils">
<colgroup>
<col width="51%" />
<col width="28%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>paletteIndex</em></td>
</tr>
</tbody>
</table>
<p>A run of length more than one is represented by a palette index
with the top bit set, followed by the length of the run as for
plain RLE.</p>
<table class="docutils">
<colgroup>
<col width="30%" />
<col width="23%" />
<col width="11%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">[Value]</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td><em>paletteIndex</em> + 128</td>
</tr>
<tr><td><em>r</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td>255</td>
<td>&nbsp;</td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td>&nbsp;</td>
<td>(<em>runLength</em> - 1) % 255</td>
</tr>
</tbody>
</table>
<p class="last">Where <em>r</em> is floor((<em>runLength</em> - 1) / 255).</p>
</dd>
</dl>
<h3><a class="toc-backref" href="#id80">7.7&nbsp;&nbsp;&nbsp;Pseudo-encodings</a></h3>
<h4><a class="toc-backref" href="#id81">7.7.1&nbsp;&nbsp;&nbsp;JPEG Quality Level Pseudo-encoding</a></h4>
<p>Specifies the desired quality from the JPEG encoder. Encoding number
-23 implies high JPEG quality and -32 implies low JPEG quality. Low
quality can be useful in low bandwidth situations. If the JPEG quality
level is not specified, <strong>JpegCompression</strong> is not used in the <a class="reference internal" href="#tight-encoding">Tight
Encoding</a>.</p>
<p>The quality level concerns lossy compression and hence the setting is a
tradeoff between image quality and bandwidth. The specification defines
neither what bandwidth is required at a certain quality level nor what
image quality you can expect. The quality level is also just a hint to
the server.</p>
<h4><a class="toc-backref" href="#id82">7.7.2&nbsp;&nbsp;&nbsp;Cursor Pseudo-encoding</a></h4>
<p>A client which requests the <em>Cursor</em> pseudo-encoding is declaring that
it is capable of drawing a mouse cursor locally. This can significantly
improve perceived performance over slow links. The server sets the
cursor shape by sending a pseudo-rectangle with the <em>Cursor</em>
pseudo-encoding as part of an update. The pseudo-rectangle's
<em>x-position</em> and <em>y-position</em> indicate the hotspot of the cursor, and
<em>width</em> and <em>height</em> indicate the width and height of the cursor in
pixels. The data consists of <em>width</em> * <em>height</em> pixel values followed
by a bitmask. The bitmask consists of left-to-right, top-to-bottom
scanlines, where each scanline is padded to a whole number of bytes
floor((<em>width</em> + 7) / 8). Within each byte the most significant bit
represents the leftmost pixel, with a 1-bit meaning the corresponding
pixel in the cursor is valid.</p>
<table class="docutils">
<colgroup>
<col width="55%" />
<col width="23%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>width</em> * <em>height</em> * <em>bytesPerPixel</em></td>
<td><tt class="docutils literal">PIXEL</tt> array</td>
<td><em>cursor-pixels</em></td>
</tr>
<tr><td>floor((<em>width</em> + 7) / 8) * <em>height</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>bitmask</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id83">7.7.3&nbsp;&nbsp;&nbsp;X Cursor Pseudo-encoding</a></h4>
<p>A client which requests the <em>X Cursor</em> pseudo-encoding is declaring
that it is capable of drawing a mouse cursor locally. This can
significantly improve perceived performance over slow links. The
server sets the cursor shape by sending a pseudo-rectangle with the
<em>X Cursor</em> pseudo-encoding as part of an update.</p>
<p>The pseudo-rectangle's <em>x-position</em> and <em>y-position</em> indicate the
hotspot of the cursor, and <em>width</em> and <em>height</em> indicate the width and
height of the cursor in pixels.</p>
<p>The data consists of the primary and secondary colours for the cursor,
followed by one bitmap for the colour and one bitmask for the
transparency. The bitmap and bitmask both consist of left-to-right,
top-to-bottom scanlines, where each scanline is padded to a whole
number of bytes floor((<em>width</em> + 7) / 8). Within each byte the most
significant bit represents the leftmost pixel, with a 1-bit meaning the
corresponding pixel should use the primary colour, or that the pixel is
valid.</p>
<table class="docutils">
<colgroup>
<col width="55%" />
<col width="23%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>primary-r</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>primary-g</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>primary-b</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>secondary-r</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>secondary-g</em></td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>secondary-b</em></td>
</tr>
<tr><td>floor((<em>width</em> + 7) / 8) * <em>height</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>bitmap</em></td>
</tr>
<tr><td>floor((<em>width</em> + 7) / 8) * <em>height</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>bitmask</em></td>
</tr>
</tbody>
</table>
<h4><a class="toc-backref" href="#id84">7.7.4&nbsp;&nbsp;&nbsp;DesktopSize Pseudo-encoding</a></h4>
<p>A client which requests the <em>DesktopSize</em> pseudo-encoding is declaring
that it is capable of coping with a change in the framebuffer width
and/or height.</p>
<p>The server changes the desktop size by sending a pseudo-rectangle with
the <em>DesktopSize</em> pseudo-encoding. The pseudo-rectangle's <em>x-position</em>
and <em>y-position</em> are ignored, and <em>width</em> and <em>height</em> indicate the new
width and height of the framebuffer. There is no further data
associated with the pseudo-rectangle.</p>
<p>The semantics of the <em>DesktopSize</em> pseudo-encoding were originally not
clearly defined and as a results there are multiple differing
implementations in the wild. Both the client and server need to take
special steps to ensure maximum compatibility.</p>
<p>In the initial implementation the <em>DesktopSize</em> pseudo-rectangle was
sent in its own update without any modifications to the framebuffer
data. The client would discard the framebuffer contents upon receiving
this pseudo-rectangle and the server would consider the entire
framebuffer to be modified.</p>
<p>A later implementation sent the <em>DesktopSize</em> pseudo-rectangle together
with modifications to the framebuffer data. It also expected the client
to retain the framebuffer contents as those modifications could be from
after the framebuffer resize had occurred on the server.</p>
<p>The semantics defined here retain compatibility with both of two older
implementations.</p>
<h5><a class="toc-backref" href="#id85">7.7.4.1&nbsp;&nbsp;&nbsp;Server Semantics</a></h5>
<p>The update containing the pseudo-rectangle should not contain any
rectangles that change the framebuffer data as that will most likely be
discarded by the client and will have to be resent later.</p>
<p>The server should assume that the client discards the framebuffer data
when receiving a <em>DesktopSize</em> pseudo-rectangle. It should therefore
not use any encoding that relies on the previous contents of the
framebuffer. The server should also consider the entire framebuffer to
be modified.</p>
<p>Some early client implementations require the <em>DesktopSize</em>
pseudo-rectangle to be the very last rectangle in an update. Servers
should make every effort to support these.</p>
<p>The server should only send a <em>DesktopSize</em> pseudo-rectangle when an
actual change of the framebuffer dimensions has occurred. Some clients
respond to a <em>DesktopSize</em> pseudo-rectangle in a way that could send
the system into an infinite loop if the server sent out the
pseudo-rectangle for anything other than an actual change.</p>
<h5><a class="toc-backref" href="#id86">7.7.4.2&nbsp;&nbsp;&nbsp;Client Semantics</a></h5>
<p>The client should assume that the server expects the framebuffer data
to be retained when the framebuffer dimensions change. This requirement
can be satisfied either by actually retaining the framebuffer data, or
by making sure that <em>incremental</em> is set to zero (false) in the next
<em>FramebufferUpdateRequest</em>.</p>
<p>The principle of one framebuffer update being a transition from one
valid state to another does not hold for updates with the <em>DesktopSize</em>
pseudo-rectangle as the framebuffer contents can temporarily be
partially or completely undefined. Clients should try to handle this
gracefully, e.g. by showing a black framebuffer or delay the screen
update until a proper update of the framebuffer contents has been
received.</p>
<h4><a class="toc-backref" href="#id87">7.7.5&nbsp;&nbsp;&nbsp;LastRect Pseudo-encoding</a></h4>
<p>A client which requests the <em>LastRect</em> pseudo-encoding is declaring
that it does not need the exact number of rectangles in a
<em>FramebufferUpdate</em> message. Instead, it will stop parsing when it
reaches a <em>LastRect</em> rectangle. A server may thus start transmitting
the <em>FramebufferUpdate</em> message before it knows exactly how many
rectangles it is going to transmit, and the server typically advertises
this situation by saying that it is going to send 65535 rectangles,
but it then stops with a <em>LastRect</em> instead of sending all of them.
There is no further data associated with the pseudo-rectangle.</p>
<h4><a class="toc-backref" href="#id88">7.7.6&nbsp;&nbsp;&nbsp;Compression Level Pseudo-encoding</a></h4>
<p>Specifies the desired compression level. Encoding number -247 implies
high compression level, -255 implies low compression level. Low
compression level can be useful to get low latency in medium to high
bandwidth situations and high compression level can be useful in low
bandwidth situations.</p>
<p>The compression level concerns lossless compression, and hence the
setting is a tradoff between CPU time and bandwidth. It is therefore
probably difficult to define exact cut-off points for which compression
levels should be used for any given bandwidth. The compression level is
just a hint for the server, and there is no specification for what a
specific compression level means.</p>
<h4><a class="toc-backref" href="#id89">7.7.7&nbsp;&nbsp;&nbsp;QEMU Pointer Motion Change Psuedo-encoding</a></h4>
<p>A client that supports this encoding declares that is able to send
pointer motion events either as absolute coordinates, or relative
deltas. The server can switch between different pointer motion modes
by sending a <a class="reference internal" href="#framebufferupdate">FrameBufferUpdate</a> message. If the <em>x-position</em> in
the update is 1, the server is requesting absolute coordinates, which
is the RFB protocol default when this encoding is not supported. If
the <em>x-position</em> in the update is 0, the server is requesting relative
deltas.</p>
<p>When relative delta mode is active, the semantics of the
<a class="reference internal" href="#pointerevent">PointerEvent</a> message are changed. The <em>x-position</em> and <em>y-position</em>
fields are to be treated as <tt class="docutils literal">S16</tt> quantities, denoting the delta
from the last position. A client can compute the signed deltas with
the logic:</p>
<pre>
uint16 dx = x + 0x7FFF - last_x
uint16 dy = y + 0x7FFF - last_y
</pre>
<p>If the client needs to send an updated <em>button-mask</em> without
any associated motion, it should use the value 0x7FFF in the
<em>x-position</em> and <em>y-position</em> fields of the <a class="reference internal" href="#pointerevent">PointerEvent</a></p>
<p>Servers are advised to implement this psuedo-encoding if the virtual
desktop is associated a input device that expects relative coordinates,
for example, a virtual machine with a PS/2 mouse. Prior to this
extension, a server with such a input device would have to perform the
absolute to relative delta conversion itself. This can result in the
client pointer hitting an &quot;invisible wall&quot;.</p>
<p>Clients are advised that when generating events in relative pointer
mode, they should grab and hide the local pointer. When the local
pointer hits any edge of the client window, it should be warped
back by 100 pixels. This ensures that continued movement of the
user's input device will continue to generate relative deltas and
thus avoid the &quot;invisible wall&quot; problem.</p>
<h4><a class="toc-backref" href="#id90">7.7.8&nbsp;&nbsp;&nbsp;QEMU Extended Key Event Psuedo-encoding</a></h4>
<p>A client that supports this encoding is indicating that it is able
to provide raw keycodes as an alternative to keysyms. If a server
wishes to receive raw keycodes it will send a <a class="reference internal" href="#framebufferupdate">FrameBufferUpdate</a>
with the matching psuedo-encoding and the <em>num-rectanges</em> field
set to 1, however, no rectanges will actually be sent. After receiving
this notification, clients may optionally use the
<a class="reference internal" href="#qemu-extended-key-event-message">QEMU Extended Key Event Message</a> to send key events, in preference
to the traditional <a class="reference internal" href="#keyevent">KeyEvent</a> message.</p>
<h4><a class="toc-backref" href="#id91">7.7.9&nbsp;&nbsp;&nbsp;QEMU Audio Psuedo-encoding</a></h4>
<p>A client that supports this encoding is indicating that it is able
to receive an audio data stream. If a server wishes to send audio
data it will send a <a class="reference internal" href="#framebufferupdate">FrameBufferUpdate</a> with the matching
psuedo-encoding and the <em>num-rectangles</em> field set to 1, however, no
rectangles will actually be sent. After receiving this notification,
clients may optionally use the <a class="reference internal" href="#qemu-audio-client-message">QEMU Audio Client Message</a>.</p>
<h4><a class="toc-backref" href="#id92">7.7.10&nbsp;&nbsp;&nbsp;gii Pseudo-encoding</a></h4>
<p>A client that supports the General Input Interface extension starts by
requesting the <em>gii</em> pseudo-encoding declaring that it is capable of
accepting the <a class="reference internal" href="#gii-server-message">gii Server Message</a>. The server, in turn, declares that
it is capable of accepting the <a class="reference internal" href="#gii-client-message">gii Client Message</a> by sending a <a class="reference internal" href="#gii-server-message">gii
Server Message</a> of subtype <em>version</em>.</p>
<p>Requesting the <em>gii</em> pseudo-encoding is the first step when a client
wants to use the <em>gii</em> extension of the RFB protocol. The <em>gii</em>
extension is used to provide a more powerful input protocol for cases
where the standard input model is insufficient. It supports relative
mouse movements, mouses with more than 8 buttons and mouses with more
than three axes. It even supports joysticks and gamepads.</p>
<h4><a class="toc-backref" href="#id93">7.7.11&nbsp;&nbsp;&nbsp;DesktopName Pseudo-encoding</a></h4>
<p>A client which requests the DesktopName pseudo-encoding is declaring
that it is capable of coping with a change of the desktop name. The
server changes the desktop name by sending a pseudo-rectangle with the
DesktopName pseudo-encoding in an update. The pseudo-rectangle's
x-position, y-position, width, and height must be zero. After the
rectangle header, a string with the new name follows.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>name-length</em></td>
</tr>
<tr><td><em>name-length</em></td>
<td><tt class="docutils literal">U8</tt> array</td>
<td><em>name-string</em></td>
</tr>
</tbody>
</table>
<p>The text encoding used for <em>name-string</em> is UTF-8.</p>
<h4><a class="toc-backref" href="#id94">7.7.12&nbsp;&nbsp;&nbsp;ExtendedDesktopSize Pseudo-encoding</a></h4>
<p>A client which requests the <em>ExtendedDesktopSize</em> pseudo-encoding is
declaring that it is capable of coping with a change in the
framebuffer width, height, and/or screen configuration. This encoding
is used in conjunction with the <em>SetDesktopSize</em> message. If a server
supports the <em>ExtendedDesktopSize</em> encoding, it must also have basic
support for the <em>SetDesktopSize</em> message although it may deny all
requests to change the screen layout.</p>
<p>The <em>ExtendedDesktopSize</em> pseudo-encoding is designed to replace the
simpler <em>DesktopSize</em> one. Servers and clients should support both for
maximum compatibility, but a server must only send the extended
version to a client asking for both. The semantics of <em>DesktopSize</em> are
not as well-defined as for <em>ExtendedDesktopSize</em> and handling both at
the same time would require needless complexity in the client.</p>
<p>The server must send an <em>ExtendedDesktopSize</em> rectangle in response to
a <em>FramebufferUpdateRequest</em> with <em>incremental</em> set to zero, assuming
the client has requested the <em>ExtendedDesktopSize</em> pseudo-encoding
using the <em>SetEncodings</em> message. This requirement is needed so that
the client has a reliable way of fetching the initial screen
configuration, and to determine if the server supports the
<em>SetDesktopSize</em> message.</p>
<p>A consequence of this is that a client must not respond to an
<em>ExtendedDesktopSize</em> rectangle by sending a <em>FramebufferUpdateRequest</em>
with <em>incremental</em> set to zero. Doing so would make the system go into
an infinite loop.</p>
<p>The server must also send an <em>ExtendedDesktopSize</em> rectangle in
response to a <em>SetDesktopSize</em> message, indicating the result.</p>
<p>For a full description of server behaviour as a result of the
<em>SetDesktopSize</em> message, <a class="reference internal" href="#setdesktopsize">SetDesktopSize</a>.</p>
<p>Rectangles sent as a result of a <em>SetDesktopSize</em> message must be sent
as soon as possible. Rectangles sent for other reasons may be subjected
to delays imposed by the server.</p>
<p>An update containing an <em>ExtendedDesktopSize</em> rectangle must not
contain any changes to the framebuffer data, neither before nor after
the <em>ExtendedDesktopSize</em> rectangle.</p>
<p>The pseudo-rectangle's <em>x-position</em> indicates the reason for the
change:</p>
<dl class="docutils">
<dt>0</dt>
<dd>The screen layout was changed via non-RFB means on the server. For
example the server may have provided means for server-side
applications to manipulate the screen layout. This code is also
used when the client sends a non-incremental
<em>FrameBufferUpdateRequest</em> to learn the server's current state.</dd>
<dt>1</dt>
<dd>The client receiving this message requested a change of the screen
layout. The change may or may not have happened depending on server
policy or available resources. The status code in the <em>y-position</em>
field must be used to determine which.</dd>
<dt>2</dt>
<dd>Another client requested a change of the screen layout and the
server approved it. A rectangle with this code is never sent if the
server denied the request.</dd>
</dl>
<p>More reasons may be added in the future. Clients should treat an
unknown value as a server-side change (i.e. as if <em>x-position</em> was set
to zero).</p>
<p>The pseudo-rectangle's <em>y-position</em> indicates the status code for a
change requested by a client:</p>
<table class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Code</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>No error</td>
</tr>
<tr><td>1</td>
<td>Resize is administratively prohibited</td>
</tr>
<tr><td>2</td>
<td>Out of resources</td>
</tr>
<tr><td>3</td>
<td>Invalid screen layout</td>
</tr>
</tbody>
</table>
<p>This field shall be set to zero by the server and ignored by clients
when not defined. Other error codes may be added in the future and
clients must treat them as an unknown failure.</p>
<p>The <em>width</em> and <em>height</em> indicates the new width and height of the
framebuffer.</p>
<p>The encoding data is defined as:</p>
<table class="docutils">
<colgroup>
<col width="39%" />
<col width="28%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal">U8</tt></td>
<td><em>number-of-screens</em></td>
</tr>
<tr><td>3</td>
<td>&nbsp;</td>
<td><em>padding</em></td>
</tr>
<tr><td><em>number-of-screens</em> * 16</td>
<td><tt class="docutils literal">SCREEN</tt> array</td>
<td><em>screens</em></td>
</tr>
</tbody>
</table>
<p>The <em>number-of-screens</em> field indicates the number of active screens
and allows for multi head configurations. It also indicates how many
<tt class="docutils literal">SCREEN</tt> structures that follows. These are defined as:</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="45%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">No. of bytes</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>id</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>x-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>y-position</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>width</em></td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">U16</tt></td>
<td><em>height</em></td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal">U32</tt></td>
<td><em>flags</em></td>
</tr>
</tbody>
</table>
<p>The <em>id</em> field contains an arbitrary value that the server and client
can use to map RFB screens to physical screens. The value must be
unique in the current set of screens and must be preserved for the
lifetime of that RFB screen. New ids are assigned by whichever side
creates the screen. An <em>id</em> may be reused if there has been a subsequent
update of the screen layout where the <em>id</em> was not used.</p>
<p>The <em>flags</em> field is currently unused. Clients and servers must ignore,
but preserve, any bits it does not understand. For new screens, those
bits must be set to zero.</p>
<p>Note that a simple client which does not support multi head does not
need to parse the list of screens and can simply display the entire
framebuffer.</p>
<h4><a class="toc-backref" href="#id95">7.7.13&nbsp;&nbsp;&nbsp;xvp Pseudo-encoding</a></h4>
<p>A client which requests the <em>xvp</em> pseudo-encoding is declaring that it
wishes to use the <em>xvp</em> extension.  If the server supports this, it
replies with a message of type <a class="reference internal" href="#xvp-server-message">xvp Server Message</a>, using an
<em>xvp-message-code</em> of <em>XVP_INIT</em>.  This informs the client that it may
then subsequently send messages of type <a class="reference internal" href="#xvp-client-message">xvp Client Message</a>.</p>
<h4><a class="toc-backref" href="#id96">7.7.14&nbsp;&nbsp;&nbsp;Fence Pseudo-encoding</a></h4>
<p>A client which requests the <em>Fence</em> pseudo-encoding is declaring that
it supports and/or wishes to use the <em>Fence</em> extension. The server
should send a <a class="reference internal" href="#serverfence">ServerFence</a> the first time it sees a <tt class="docutils literal">SetEncodings</tt>
message with the <em>Fence</em> pseudo-encoding, in order to inform the client
that this extension is supported. The message can use any flags or
payload.</p>
<h4><a class="toc-backref" href="#id97">7.7.15&nbsp;&nbsp;&nbsp;ContinuousUpdates Pseudo-encoding</a></h4>
<p>A client which requests the <em>ContinuousUpdates</em> pseudo-encoding is
declaring that it wishes to use the <a class="reference internal" href="#enablecontinuousupdates">EnableContinuousUpdates</a>
extension. The server must send a <a class="reference internal" href="#endofcontinuousupdates">EndOfContinuousUpdates</a> message the
first time it sees a <tt class="docutils literal">SetEncodings</tt> message with the
<em>ContinuousUpdates</em> pseudo-encoding, in order to inform the client that
the extension is supported.</p>
<h4><a class="toc-backref" href="#id98">7.7.16&nbsp;&nbsp;&nbsp;JPEG Fine-Grained Quality Level Pseudo-encoding</a></h4>
<p>The JPEG Fine-Grained Quality Level pseudo-encoding allows the image
quality to be specified on a 0 to 100 scale, with -512 corresponding to image
quality 0 and -412 corresponding to image quality 100.  This pseudo-encoding
was originally intended for use with JPEG-encoded subrectangles, but it could
be used with other types of image encoding as well.</p>
<h4><a class="toc-backref" href="#id99">7.7.17&nbsp;&nbsp;&nbsp;JPEG Subsampling Level Pseudo-Encoding</a></h4>
<p>The JPEG Subsampling Level pseudo-encoding allows the level of chrominance
subsampling to be specified.  When a JPEG image is encoded, the RGB pixels are
first converted to YCbCr, a colorspace in which brightness (luminance) is
separated from color (chrominance.)  Since the human eye is more sensitive to
spatial changes in brightness than to spatial changes in color, the chrominance
components (Cb, Cr) can be subsampled to save bandwidth without losing much
image quality (on smooth images, such as photographs, chrominance subsampling
is often not distinguishable by the human eye.)  Subsampling can be implemented
either by averaging together groups of chrominance components or by simply
picking one component from the group and discarding the rest.</p>
<p>The values for this pseudo-encoding are defined as follows:</p>
<dl class="docutils">
<dt>-768 = 1X chrominance subsampling (no chrominance subsampling).</dt>
<dd>Chrominance components are sent for every pixel in the source image.</dd>
<dt>-767 = 4X chrominance subsampling.  Chrominance components are sent for every</dt>
<dd>fourth pixel in the source image.  This would typically be implemented
using 4:2:0 subsampling (2X subsampling in both X and Y directions), but
it could also be implemented using 4:1:1 subsampling (4X subsampling in
the X direction.)</dd>
<dt>-766 = 2X chrominance subsampling.  Chrominance components are sent for every</dt>
<dd>other pixel in the source image.  This would typically be implemented
using 4:2:2 subsampling (2X subsampling in the X direction.)</dd>
<dt>-765 = Grayscale.  All chrominance components in the source image are</dt>
<dd>discarded.</dd>
<dt>-764 = 8X chrominance subsampling.  Chrominance components are sent for every</dt>
<dd>8th pixel in the source image.  This would typically be implemented
using 4:1:0 subsampling (4X subsampling in the X direction and 2X
subsampling in the Y direction.)</dd>
<dt>-763 = 16X chrominance subsampling.  Chrominance components are sent for every</dt>
<dd>16th pixel in the source image.  This would typically be implemented
using 4X subsampling in both X and Y directions.</dd>
</dl>
<p>This pseudo-encoding was originally intended for use with JPEG-encoded
subrectangles, but it could be used with other types of image encoding as well.</p>